<!-- deployement v8 - Final Bug Fixes -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Word Grid Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            overflow-x: hidden;
        }
        .die {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .die.selected {
            transform: scale(0.9) rotate(5deg);
            background-color: #fbbf24; /* amber-400 */
            color: #1f2937; /* gray-800 */
        }
        .modal-bg {
            background-color: rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s ease;
        }
       .modal-bg.hidden, .modal.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }
        .panel {
            transition: opacity 0.5s ease, transform 0.5s ease, width 0.5s ease;
        }
        .panel-hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
            width: 0 !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .word-list-item:hover {
            background-color: #e5e7eb;
        }
        .modal {
            position: fixed;
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            overflow: hidden; 
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .modal-header {
            cursor: move;
            background-color: #f9fafb; /* gray-50 */
            border-bottom: 1px solid #e5e7eb; /* gray-200 */
        }
        .resize-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            right: 0;
            bottom: 0;
            cursor: nwse-resize;
            background-image: linear-gradient(135deg, transparent 0%, transparent 50%, #6b7280 50%, #6b7280 100%);
        }
        .host-override-btn {
            display: none;
        }
        .edit-mode .host-override-btn {
            display: inline-block;
        }
        .word-overridden-approve {
            background-color: #dcfce7 !important; /* green-100 */
        }
        .word-overridden-reject {
            background-color: #fee2e2 !important; /* red-100 */
        }
        #countdown-overlay {
            font-size: 15vw;
            text-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .mic-btn.listening {
            animation: pulse 1.5s infinite;
            background-color: #ef4444; /* red-500 */
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .shake {
            animation: shake 0.5s;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen relative">

    <div id="app-container" class="w-full max-w-7xl mx-auto p-4 flex flex-col items-center gap-6">
        <!-- Help Button -->
        <button id="how-to-play-btn" class="absolute top-4 right-4 bg-teal-500 text-white h-16 w-16 rounded-full shadow-lg text-4xl font-bold flex items-center justify-center hover:bg-teal-600 z-30 hidden">?</button>
    
        <!-- Lobby View -->
        <div id="lobby-view" class="w-full hidden flex-col gap-6 items-center">
             <div class="w-full max-w-sm bg-white p-6 rounded-2xl shadow-lg">
                <label class="font-semibold text-gray-600">Welcome, <span id="lobby-player-name" class="font-bold"></span>!</label>
            </div>
            <div class="w-full flex flex-col md:flex-row gap-6 justify-center">
                <!-- Create Game Panel -->
                <div id="create-game-panel" class="w-full md:w-1/2 bg-white p-6 rounded-2xl shadow-lg flex flex-col gap-4">
                     <h2 class="text-2xl font-bold text-gray-700">Create Game</h2>
                     <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="timer-setting" class="font-semibold text-gray-600">Time (s):</label>
                            <input type="number" id="timer-setting" value="45" min="30" max="300" class="w-full mt-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                        </div>
                        <div>
                            <label for="min-word-length" class="font-semibold text-gray-600">Min Length:</label>
                            <input type="number" id="min-word-length" value="3" min="2" max="10" class="w-full mt-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                        </div>
                    </div>
                     <div class="grid grid-cols-2 gap-4">
                         <div>
                            <label for="grid-size" class="font-semibold text-gray-600">Grid Size:</label>
                            <select id="grid-size" class="w-full mt-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                                <option value="4" selected>4x4</option>
                                <option value="5">5x5</option>
                                <option value="6">6x6</option>
                            </select>
                        </div>
                     </div>
                     <div>
                        <label class="font-semibold text-gray-600">Word Filters:</label>
                        <div class="flex flex-wrap gap-2 my-2" id="filter-tags-container"></div>
                        <div class="flex gap-2">
                            <input type="text" id="filter-input" placeholder="e.g., adjective" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                            <button id="add-filter-btn" class="bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600">+</button>
                        </div>
                    </div>
                    <button id="create-game-btn" class="w-full bg-green-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-600 transition-colors duration-300 shadow-md mt-auto">Create New Game</button>
                </div>
                <!-- Join Game Panel -->
                <div class="w-full md:w-1/2 bg-white p-6 rounded-2xl shadow-lg flex flex-col gap-4">
                     <h2 class="text-2xl font-bold text-gray-700">Join Game</h2>
                     <p class="text-gray-600">Ask a friend for their Game ID to join their room.</p>
                     <div class="flex gap-2 mt-auto">
                         <input type="text" id="join-game-id-input" placeholder="Enter Game ID" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 transition">
                         <button id="join-game-btn" class="bg-gray-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-gray-700 transition-colors duration-300 shadow-md">Join</button>
                     </div>
                     <div id="join-error-msg" class="text-red-500 text-sm mt-2 hidden"></div>
                </div>
            </div>
        </div>

        <!-- Game View -->
        <div id="game-view" class="w-full flex-row gap-6 hidden">
            <div id="left-panel" class="panel lg:w-1/4 bg-white p-6 rounded-2xl shadow-lg flex-col gap-6 order-2 lg:order-1 h-fit flex">
                <div id="game-info-controls"></div>
                <div id="leaderboard-summary" class="cursor-pointer">
                    <h2 class="text-2xl font-bold text-gray-700 mb-4 hover:text-indigo-600">Leaderboard ðŸ”Ž</h2>
                    <div id="leaderboard" class="space-y-2"></div>
                </div>
                 <div>
                    <h3 class="text-xl font-bold text-gray-700 mb-2">My User ID</h3>
                     <p id="user-id-display" class="text-xs text-gray-500 break-all"></p>
                </div>
            </div>

            <div id="center-panel" class="flex-grow bg-white p-6 rounded-2xl shadow-lg order-1 lg:order-2 flex flex-col items-center justify-center">
                 <div class="w-full flex items-center justify-between mb-2">
                    <!-- <button id="show-panels-btn" class="hidden bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300">Show Info</button> -->
                    <div class="w-28"></div> <!-- This is a spacer -->
                </div>

                <div class="text-center mb-4">
                    <div class="flex justify-center items-center gap-4">
                        <div id="timer-display" class="text-6xl font-bold text-indigo-600">00:00</div>
                        <button id="mic-btn" class="mic-btn hidden bg-blue-500 text-white p-3 rounded-full hover:bg-blue-600 transition-all">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v3a3 3 0 01-3 3z"></path></svg>
                        </button>
                    </div>
                    <div id="game-status-display" class="text-lg text-gray-500 mt-1"></div>
                </div>
                <div id="game-grid" class="grid gap-2 aspect-square w-full max-w-lg"></div>
            </div>

            <div id="right-panel" class="panel lg:w-1/4 bg-white p-6 rounded-2xl shadow-lg flex-col gap-4 order-3 h-fit flex">
                 <div>
                    <h2 class="text-2xl font-bold text-gray-700 mb-4">Current Word</h2>
                    <!-- <div id="current-word-display" class="w-full h-16 bg-gray-100 rounded-lg flex items-center justify-center text-3xl font-semibold tracking-widest border-2 border-dashed"></div> -->
                     <input id="current-word-input" class="w-full h-16 bg-gray-100 rounded-lg text-center text-3xl font-semibold tracking-widest border-2 border-dashed" placeholder="">
                    <div class="flex gap-2 mt-4">
                        <button id="submit-word-btn" class="flex-grow bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg">Submit</button>
                        <button id="clear-word-btn" class="bg-red-500 text-white font-bold py-3 px-4 rounded-lg">Clear</button>
                    </div>
                </div>
                <div>
                    <h2 class="text-2xl font-bold text-gray-700 mb-4">My Words</h2>
                    <ul id="my-words-list" class="h-64 overflow-y-auto bg-gray-50 p-3 rounded-lg border"></ul>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modals -->
     <div id="welcome-modal-bg" class="modal-bg fixed inset-0 z-40 flex items-center justify-center hidden">
        <div id="welcome-modal" class="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-sm flex flex-col gap-6">
            <h2 class="text-3xl font-bold text-center text-gray-800">Welcome!</h2>
            <div>
                <label for="player-name-modal" class="font-semibold text-gray-600">Choose Your Name:</label>
                <div class="flex gap-2 mt-1">
                    <input type="text" id="player-name-modal" placeholder="e.g., WordWizard" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                    <button id="suggest-name-btn" title="Suggest Name" class="bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300">ðŸ’¡</button>
                </div>
                 <p id="name-error-msg" class="text-red-500 text-sm mt-1 hidden">Please enter a name.</p>
            </div>
            <button id="enter-lobby-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 shadow-md">Enter Lobby</button>
        </div>
    </div>

        <!-- How to Play Modal -->
    <div id="how-to-play-modal-bg" class="modal-bg fixed inset-0 z-50 flex items-center justify-center hidden">
        <div id="how-to-play-modal" class="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-md flex flex-col gap-4 relative">
            <button id="close-how-to-play-btn" class="absolute top-4 right-4 text-2xl font-bold hover:text-red-500">&times;</button>
            <h2 class="text-3xl font-bold text-center text-gray-800">How to Play</h2>
            <ul class="space-y-3 list-disc list-inside text-gray-700">
                <li>Form words using letters from the grid.</li>
                <li>Letters do not need to be adjacent.</li>
                <li>Each letter tile can only be used once per word.</li>
            </ul>
            <h3 class="text-xl font-bold text-center text-gray-800 mt-4">Controls</h3>
            <ul class="space-y-2 text-gray-700">
                <li class="flex items-center gap-4"><span class="font-bold inline-block w-28 text-right">Space Bar</span> - <span>Activate microphone for voice input.</span></li>
                <li class="flex items-center gap-4"><span class="font-bold inline-block w-28 text-right">Enter</span> - <span>Submit the current word.</span></li>
                <li class="flex items-center gap-4"><span class="font-bold inline-block w-28 text-right">Backspace</span> - <span>Remove the last selected letter.</span></li>
                <li class="flex items-center gap-4"><span class="font-bold inline-block w-28 text-right">Mouse Click</span> - <span>Select letters from the grid.</span></li>
                <li class="flex items-center gap-4"><span class="font-bold inline-block w-28 text-right">Keyboard</span> - <span>Type letters to select them.</span></li>
            </ul>
        </div>
    </div>

    <div id="ready-check-modal-bg" class="modal-bg fixed inset-0 z-50 flex items-center justify-center hidden">
        <div class="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-md flex flex-col gap-4">
            <h2 class="text-3xl font-bold text-center text-gray-800">Ready Check!</h2>
            <div id="ready-check-list" class="space-y-3"></div>
            <button id="force-start-btn" class="hidden w-full bg-red-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-red-600 shadow-md disabled:bg-gray-400 disabled:cursor-not-allowed">Force Start</button>
        </div>
    </div>

    <div id="countdown-overlay" class="modal-bg bg-slate-900 fixed inset-0 z-50 hidden items-center justify-center text-white font-bold"></div>

    <div id="scoring-modal" class="modal hidden" style="width: 800px; height: 600px; top: 15%; left: 25%; z-index: 50;">
        <div id="scoring-modal-header" class="modal-header p-4 flex justify-between items-center"><h2 class="text-2xl font-bold text-center flex-grow">Round Over!</h2><button id="close-scoring-modal-btn" class="text-2xl font-bold">&times;</button></div>
        <div class="p-6 h-[calc(100%-60px)] flex flex-col">
            <div id="scoring-host-controls" class="hidden mb-4 p-3 border-b flex justify-between items-center bg-gray-50 rounded-lg">
                 <label class="flex items-center justify-center gap-2 font-semibold"><input type="checkbox" id="edit-scores-toggle" class="h-5 w-5 rounded"> Edit Scores (Host)</label>
                 <button id="apply-overrides-btn" class="hidden bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">Apply & Recalculate</button>
            </div>
            <div id="scoring-modal-content" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 overflow-y-auto flex-grow"></div>
            <div class="mt-4 text-center">
                <button id="reveal-top-words-btn" class="bg-purple-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-purple-700 disabled:bg-gray-400" disabled>Reveal Interesting Possible Words ðŸ’¡</button>
            </div>
        </div>
        <div class="resize-handle"></div>
    </div>
    <div id="standings-modal" class="modal hidden" style="width: 900px; height: 700px; top: 10%; left: 20%; z-index: 50;">
        <div id="standings-modal-header" class="modal-header p-4 flex justify-between items-center"><h2 class="text-2xl font-bold">Standings & History</h2><button id="close-standings-modal-btn" class="text-2xl font-bold">&times;</button></div>
        <div id="standings-modal-content" class="p-6 overflow-y-auto h-[calc(100%-60px)]"></div>
        <div class="resize-handle"></div>
    </div>
    <div id="dictionary-modal" class="modal hidden" style="width: 450px; height: 500px; top: 20%; left: 35%; z-index: 60;">
        <div id="dictionary-modal-header" class="modal-header p-4 flex justify-between items-center"><h2 id="dictionary-word" class="text-2xl font-bold">Word</h2><button id="close-dictionary-btn" class="text-2xl font-bold">&times;</button></div>
        <div id="dictionary-definition" class="p-6 text-sm text-gray-700 overflow-y-auto h-[calc(100%-60px)]"></div>
        <div class="resize-handle"></div>
    </div>
    <div id="top-words-modal" class="modal hidden" style="width: 500px; height: 600px; top: 15%; left: 33%; z-index: 70;">
        <div id="top-words-modal-header" class="modal-header p-4 flex justify-between items-center"><h2 class="text-2xl font-bold">Top Possible Words</h2><button id="close-top-words-btn" class="text-2xl font-bold">&times;</button></div>
        <div id="top-words-content" class="p-6 overflow-y-auto h-[calc(100%-60px)]"></div>
        <div class="resize-handle"></div>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, getDocs, writeBatch, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Use environment variables for Firebase config and App ID for security and flexibility.
        const firebaseConfig = {
          apiKey: "AIzaSyD_CHO-e69XJJh8NoD6fm4ih1YryuRCWeY",
          authDomain: "word-grid-game-live.firebaseapp.com",
          projectId: "word-grid-game-live",
          storageBucket: "word-grid-game-live.firebasestorage.app",
          messagingSenderId: "216890772517",
          appId: "1:216890772517:web:71d2d55f4adf295db043cc"
        };
        const appId = 'word-game';
        
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        // Game constants
        const DICE = ['A','A','E','E','G','N', 'A','B','B','J','O','O', 'A','C','H','O','P','S', 'A','F','F','K','P','S','A','O','O','T','T','W', 'C','I','M','O','T','U', 'D','E','I','L','R','X', 'D','E','L','R','V','Y','D','I','S','T','T','Y', 'E','E','G','H','N','W', 'E','E','I','N','S','U', 'E','H','R','T','V','W','E','I','O','S','S','T', 'E','L','R','T','T','Y', 'H','I','M','N','U','Q', 'H','L','N','N','R','Z'];
        const SUGGESTED_NAMES = ['LexiconLasso', 'WordWizard', 'GridGuru', 'AlphaAvenger', 'VowelViper', 'ConsonantKing', 'SyllableSlayer'];
        
        // State variables
        let userId = null, gameId = null, gameData = {}, playerWords = {}, currentWord = [], gameUnsubscribe = null, wordsUnsubscribe = {}, timerInterval = null;
        let highestZ = 70;
        let localOverrides = {};
        let playerName = '';
        let forceStartTimer = null;
        let recognition;

        // DOM element references
        const el = {
            lobbyView: document.getElementById('lobby-view'),
            gameView: document.getElementById('game-view'), 
            leftPanel: document.getElementById('left-panel'),
            rightPanel: document.getElementById('right-panel'), 
            createGameBtn: document.getElementById('create-game-btn'), 
            joinGameBtn: document.getElementById('join-game-btn'),
            joinGameIdInput: document.getElementById('join-game-id-input'), 
            joinErrorMsg: document.getElementById('join-error-msg'), 
            gameInfoControls: document.getElementById('game-info-controls'), 
            timerSetting: document.getElementById('timer-setting'), 
            minWordLength: document.getElementById('min-word-length'), 
            gridSize: document.getElementById('grid-size'), 
            filterInput: document.getElementById('filter-input'), 
            addFilterBtn: document.getElementById('add-filter-btn'), 
            filterTagsContainer: document.getElementById('filter-tags-container'),
            leaderboard: document.getElementById('leaderboard'), 
            leaderboardSummary: document.getElementById('leaderboard-summary'), 
            userIdDisplay: document.getElementById('user-id-display'),
            timerDisplay: document.getElementById('timer-display'), 
            gameStatusDisplay: document.getElementById('game-status-display'), 
            gameGrid: document.getElementById('game-grid'),
            currentWordInput: document.getElementById('current-word-input'), 
            submitWordBtn: document.getElementById('submit-word-btn'), 
            clearWordBtn: document.getElementById('clear-word-btn'),
            myWordsList: document.getElementById('my-words-list'),
            micBtn: document.getElementById('mic-btn'), 
            scoringModal: document.getElementById('scoring-modal'), 
            scoringHostControls: document.getElementById('scoring-host-controls'),
            editScoresToggle: document.getElementById('edit-scores-toggle'), 
            scoringModalContent: document.getElementById('scoring-modal-content'), 
            closeScoringModalBtn: document.getElementById('close-scoring-modal-btn'), 
            dictionaryModal: document.getElementById('dictionary-modal'), 
            dictionaryWord: document.getElementById('dictionary-word'), 
            dictionaryDefinition: document.getElementById('dictionary-definition'), 
            closeDictionaryBtn: document.getElementById('close-dictionary-btn'), 
            showPanelsBtn: document.getElementById('show-panels-btn'), 
            standingsModal: document.getElementById('standings-modal'), 
            standingsModalContent: document.getElementById('standings-modal-content'), 
            closeStandingsModalBtn: document.getElementById('close-standings-modal-btn'),
            applyOverridesBtn: document.getElementById('apply-overrides-btn'),
            revealTopWordsBtn: document.getElementById('reveal-top-words-btn'),
            topWordsModal: document.getElementById('top-words-modal'),
            topWordsContent: document.getElementById('top-words-content'),
            closeTopWordsBtn: document.getElementById('close-top-words-btn'),
            lobbyPlayerName: document.getElementById('lobby-player-name'),
            // Welcome Modal elements
            welcomeModalBg: document.getElementById('welcome-modal-bg'),
            playerNameModalInput: document.getElementById('player-name-modal'),
            suggestNameBtn: document.getElementById('suggest-name-btn'),
            enterLobbyBtn: document.getElementById('enter-lobby-btn'),
            nameErrorMsg: document.getElementById('name-error-msg'),
            // Ready Check elements
            readyCheckModalBg: document.getElementById('ready-check-modal-bg'),
            readyCheckList: document.getElementById('ready-check-list'),
            forceStartBtn: document.getElementById('force-start-btn'),
            // Countdown overlay
            countdownOverlay: document.getElementById('countdown-overlay'),
            howToPlayBtn: document.getElementById('how-to-play-btn'),
            howToPlayModalBg: document.getElementById('how-to-play-modal-bg'),
            closeHowToPlayBtn: document.getElementById('close-how-to-play-btn')
        };

        // --- Speech Recognition Setup ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            recognition.onresult = (event) => {
                const spokenWord = event.results[0][0].transcript;
                processSpokenWord(spokenWord);
            };

            recognition.onspeechend = () => {
                recognition.stop();
                el.micBtn.classList.remove('listening');
                el.currentWordInput.placeholder = '';
            };

            recognition.onerror = (event) => {
                console.error("Speech recognition error", event.error);
                el.micBtn.classList.remove('listening');
                el.currentWordInput.placeholder = 'Mic error';
            };
        } else {
            console.log("Speech Recognition not supported in this browser.");
            if(el.micBtn) el.micBtn.style.display = 'none';
        }

        // --- Authentication ---
        onAuthStateChanged(auth, async (user) => {
            if (user) { 
                userId = user.uid; 
                el.userIdDisplay.textContent = userId; 
                if (!playerName) {
                    el.welcomeModalBg.classList.remove('hidden');
                }
            } else { 
                try { 
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth); 
                    }
                } catch(error) { 
                    console.error("Sign-In Error:", error); 
                }
            }
        });
        
        // --- Event Listeners ---
        el.createGameBtn.addEventListener('click', handleCreateGame);
        el.joinGameBtn.addEventListener('click', handleJoinGame);
        el.submitWordBtn.addEventListener('click', handleSubmitWord);
        el.clearWordBtn.addEventListener('click', clearCurrentWord);
        el.micBtn.addEventListener('click', handleMicClick); // <-- ADD THIS
        el.closeScoringModalBtn.addEventListener('click', () => el.scoringModal.classList.add('hidden'));
        el.closeDictionaryBtn.addEventListener('click', hideDefinition);
        el.addFilterBtn.addEventListener('click', addFilterTag);
        el.filterInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addFilterTag(); });
        // el.showPanelsBtn.addEventListener('click', togglePanels);
        el.leaderboardSummary.addEventListener('click', showStandingsModal);
        el.closeStandingsModalBtn.addEventListener('click', () => el.standingsModal.classList.add('hidden'));
        el.editScoresToggle.addEventListener('change', (e) => {
            el.scoringModalContent.classList.toggle('edit-mode', e.target.checked);
            el.applyOverridesBtn.classList.toggle('hidden', !e.target.checked);
            el.revealTopWordsBtn.disabled = e.target.checked;
        });
        el.applyOverridesBtn.addEventListener('click', handleApplyOverrides);
        el.revealTopWordsBtn.addEventListener('click', handleRevealTopWords);
        el.closeTopWordsBtn.addEventListener('click', () => el.topWordsModal.classList.add('hidden'));
        window.addEventListener('keydown', handleKeyDown);
        el.enterLobbyBtn.addEventListener('click', handleEnterLobby);
        el.suggestNameBtn.addEventListener('click', suggestName);
        el.forceStartBtn.addEventListener('click', () => initiateRoundStart(true));

        el.howToPlayBtn.addEventListener('click', () => el.howToPlayModalBg.classList.remove('hidden'));
        el.closeHowToPlayBtn.addEventListener('click', () => el.howToPlayModalBg.classList.add('hidden'));
        el.howToPlayModalBg.addEventListener('click', (e) => {
            if (e.target.id === 'how-to-play-modal-bg') {
                el.howToPlayModalBg.classList.add('hidden');
            }
        });

        // --- Modal Setup ---
        setupModal(el.scoringModal);
        setupModal(el.standingsModal);
        setupModal(el.dictionaryModal);
        setupModal(el.topWordsModal);

        function handleMicClick() {
            if (!recognition) return;
            clearCurrentWord();
            el.micBtn.classList.add('listening');
            el.currentWordInput.placeholder = 'Listening...';
            recognition.start();
        }

        function processSpokenWord(transcript) {
            const word = transcript.replace(/\s+/g, '').trim().toUpperCase();
            if (word.length === 0) return;

            clearCurrentWord(); // Start fresh

            const availableDice = Array.from(document.querySelectorAll('#game-grid .die'));
            const tempCurrentWord = [];
            const usedIndices = new Set();
            let canBeFormed = true;

            for (const letter of word) {
                let foundDieForLetter = false;
                for (let i = 0; i < availableDice.length; i++) {
                    if (!usedIndices.has(i) && availableDice[i].textContent === letter) {
                        const dieEl = availableDice[i];
                        const { row, col } = dieEl.dataset;
                        tempCurrentWord.push({ letter, row: parseInt(row), col: parseInt(col), el: dieEl });
                        usedIndices.add(i);
                        foundDieForLetter = true;
                        break; 
                    }
                }
                if (!foundDieForLetter) {
                    canBeFormed = false;
                    break;
                }
            }

            if (canBeFormed) {
                currentWord = tempCurrentWord;
                currentWord.forEach(dieInfo => dieInfo.el.classList.add('selected'));
                renderCurrentWord(); 
            } else {
                el.currentWordInput.classList.add('shake');
                el.currentWordInput.value = ''; 
                setTimeout(() => {
                    el.currentWordInput.classList.remove('shake');
                }, 500);
                clearCurrentWord();
            }
        }
        
        // --- Lobby Functions ---
        function getPlayerName() {
            return playerName || `Player_${crypto.randomUUID().substring(0, 4)}`;
        }

        function suggestName() {
            const baseName = SUGGESTED_NAMES[Math.floor(Math.random() * SUGGESTED_NAMES.length)];
            const randomNumber = Math.floor(100 + Math.random() * 900);
            el.playerNameModalInput.value = `${baseName}${randomNumber}`;
        }

        function handleEnterLobby() {
            const nameFromModal = el.playerNameModalInput.value.trim();
            if (!nameFromModal) {
                el.nameErrorMsg.classList.remove('hidden');
                return;
            }
            playerName = nameFromModal;
            el.lobbyPlayerName.textContent = playerName;
            el.nameErrorMsg.classList.add('hidden');
            el.welcomeModalBg.classList.add('hidden');
            el.lobbyView.classList.remove('hidden');
            el.lobbyView.classList.add('flex');
        }

        function createFilterTag(text) { 
            const tag = document.createElement('div'); 
            tag.className = "flex items-center bg-indigo-100 text-indigo-700 text-sm font-semibold px-3 py-1 rounded-full"; 
            tag.textContent = text; 
            const removeBtn = document.createElement('button'); 
            removeBtn.className = "ml-2 text-indigo-500 hover:text-indigo-700 font-bold"; 
            removeBtn.innerHTML = '&times;'; 
            removeBtn.onclick = () => tag.remove(); 
            tag.appendChild(removeBtn); 
            el.filterTagsContainer.appendChild(tag); 
        }

        function addFilterTag() { 
            const text = el.filterInput.value.trim().toLowerCase(); 
            if (text) { createFilterTag(text); el.filterInput.value = ''; }
        }

        ['noun', 'verb', 'adjective', 'no-plurals','adverb'].forEach(createFilterTag);

        async function handleCreateGame() {
            if (!userId) return;
            const newGameId = crypto.randomUUID().split('-')[0];
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, newGameId);
            const playerInfo = { name: getPlayerName(), score: 0, roundScore: 0, history: {}, isReady: false };
            const filters = Array.from(el.filterTagsContainer.children).map(tag => tag.firstChild.textContent.trim());
            try { 
                await setDoc(gameRef, { 
                    createdAt: new Date(), 
                    hostId: userId, 
                    status: 'waiting', 
                    timerDuration: parseInt(el.timerSetting.value, 10), 
                    minWordLength: parseInt(el.minWordLength.value, 10), 
                    gridSize: parseInt(el.gridSize.value, 10), 
                    wordFilters: filters, 
                    grid: '[]', 
                    players: { [userId]: playerInfo }, 
                    round: 0, 
                    validWordsByRound: {},
                    topWordsByRound: {},
                    roundOverrides: {} 
                }); 
                await joinGame(newGameId); 
            } catch (error) { console.error("Error creating game:", error); }
        }

        async function handleEndOfRoundScoring() {
            try {
                // First, run the final, authoritative score calculation.
                await calculateScores(true);
                
                // ONLY after the scores are calculated and saved, update the status.
                // This is the signal for all clients to open the scoring modal.
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
                await updateDoc(gameRef, { status: 'scoring' });

            } catch (error) {
                console.error("A critical error occurred during the scoring process:", error);
                // As a fallback, set the status to 'scoring' anyway so the game doesn't get stuck.
                const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
                await updateDoc(gameRef, { status: 'scoring' });
            }
        }
        
        function handleJoinGame() { 
            el.joinErrorMsg.classList.add('hidden'); 
            const gameIdToJoin = el.joinGameIdInput.value.trim(); 
            if (gameIdToJoin) joinGame(gameIdToJoin); 
        }

        async function joinGame(id) {
            if (!userId) return;
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, id);
            try {

                const gameSnap = await getDoc(gameRef);
                if (!gameSnap.exists()) { 
                    el.joinErrorMsg.textContent = "Game not found. Please check the ID."; 
                    el.joinErrorMsg.classList.remove('hidden'); 
                    return; 
                }
                const game = gameSnap.data();

                if (gameUnsubscribe) gameUnsubscribe();
                Object.values(wordsUnsubscribe).forEach(unsub => unsub());
                wordsUnsubscribe = {}; 
                
                gameId = id;

                if (!game.players[userId]) { 
                    const playerInfo = { name: getPlayerName(), score: 0, roundScore: 0, history: {}, isReady: false }; 
                    await updateDoc(gameRef, { [`players.${userId}`]: playerInfo }); 
                }

                el.lobbyView.style.display = 'none'; 
                el.lobbyView.style.display = 'none'; 
                el.gameView.classList.remove('hidden'); 
                el.gameView.classList.add('flex');
                el.howToPlayBtn.classList.remove('hidden'); // Show the button
                el.gameView.classList.remove('hidden'); 
                el.gameView.classList.add('flex');

                gameUnsubscribe = onSnapshot(gameRef, (doc) => { 
                    const oldStatus = gameData?.status;
                    gameData = doc.data(); 
                    if (gameData) {
                                // If the host sees the 'calculating' status, it takes over the scoring process.
                                if (userId === gameData.hostId && gameData.status === 'calculating' && oldStatus !== 'calculating') {
                                    handleEndOfRoundScoring();
                                } else {
                                    // All other players (and the host on other updates) just render the current state.
                                    renderGame(oldStatus);
                                }

                                listenForPlayerWords(); // This should be called on every update to catch new players

                                // The ready-check logic remains the same.
                                if (gameData.status === 'ready-check' && userId === gameData.hostId) {
                                    const allReady = Object.values(gameData.players).every(p => p.isReady);
                                    if (allReady) {
                                        initiateRoundStart();
                                    }
                                }
                            }
                        });
            } catch (error) { 
                console.error("Error joining game:", error); 
                el.joinErrorMsg.textContent = "An error occurred while joining the game."; 
                el.joinErrorMsg.classList.remove('hidden'); 
            }
        }
        
        // --- Host Controls ---
        // async function handleStartGame() {
        //     if (!gameId || gameData.hostId !== userId) return;
        //     const updatedPlayers = { ...gameData.players };
        //     Object.keys(updatedPlayers).forEach(pid => { updatedPlayers[pid].isReady = false; });
        //     await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), { 
        //         status: 'ready-check',
        //         players: updatedPlayers
        //     });
        // }
        async function handleStartGame() {
            if (!gameId || gameData.hostId !== userId) return;
            
            // Read the new settings from the in-game controls
            const newTimer = parseInt(document.getElementById('timer-setting-ingame').value, 10);
            const newMinLength = parseInt(document.getElementById('min-word-length-ingame').value, 10);

            const updatedPlayers = { ...gameData.players };
            Object.keys(updatedPlayers).forEach(pid => { updatedPlayers[pid].isReady = false; });
            
            await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), { 
                status: 'ready-check',
                players: updatedPlayers,
                // Apply the new settings for the next round
                timerDuration: newTimer,
                minWordLength: newMinLength
            });
        }
        
        async function initiateRoundStart(forced = false) {
             if (!gameId || gameData.hostId !== userId) return;
             if (gameData.status === 'starting' || gameData.status === 'playing') return;
             if (gameData.status !== 'ready-check' && !forced) return;

             clearTimeout(forceStartTimer);

             const currentRound = (gameData.round || 0) + 1;
             const size = gameData.gridSize;
             const shuffledDice = DICE.sort(() => 0.5 - Math.random());
             const newGrid = Array.from({ length: size }, (_, r) => Array.from({ length: size }, (_, c) => shuffledDice[(r * size + c) % shuffledDice.length]));
            
             const updatedPlayers = { ...gameData.players };
             Object.keys(updatedPlayers).forEach(pid => { updatedPlayers[pid].roundScore = 0; });
            
             const batch = writeBatch(db);
             Object.keys(gameData.players).forEach(pid => { 
                 const wordsRef = doc(db, `artifacts/${appId}/public/data/games/${gameId}/playerWords`, pid); 
                 batch.set(wordsRef, { [currentRound]: [] }, { merge: true }); 
             });
             await batch.commit();

             await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), { 
                 status: 'starting', 
                 grid: JSON.stringify(newGrid), 
                 round: currentRound, 
                 players: updatedPlayers, 
                 timer: gameData.timerDuration, 
                 [`roundOverrides.${currentRound}`]: {},
                 [`validWordsByRound.${currentRound}`]: [],
                 [`topWordsByRound.${currentRound}`]: [],
             });

             getTopWordsFromGemini(newGrid.flat(), gameData.wordFilters, currentRound);
        }

        async function handleRestartGame() { 
            if (!gameId || gameData.hostId !== userId) return; 
            location.reload(); 
        }

        async function handlePauseResumeGame() { 
            if (!gameId || gameData.hostId !== userId) return; 
            const newStatus = gameData.status === 'playing' ? 'paused' : 'playing'; 
            await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), { status: newStatus });
        }

        async function handleApplyOverrides() {
            if (userId !== gameData.hostId || Object.keys(localOverrides).length === 0) return;
            
            el.applyOverridesBtn.disabled = true;
            el.applyOverridesBtn.textContent = 'Applying...';
            
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            const currentOverrides = gameData.roundOverrides?.[gameData.round] || {};
            const newOverrides = { ...currentOverrides, ...localOverrides };
            
            await updateDoc(gameRef, { [`roundOverrides.${gameData.round}`]: newOverrides });
            
            await calculateScores(true);
            
            localOverrides = {};
            el.editScoresToggle.checked = false;
            el.scoringModalContent.classList.remove('edit-mode');
            el.applyOverridesBtn.classList.add('hidden');
            el.applyOverridesBtn.disabled = false;
            el.applyOverridesBtn.textContent = 'Apply & Recalculate';
        }
        
        // --- Gameplay Functions ---
        async function handleSubmitWord() {
            const word = currentWord.map(w => w.letter).join('').toUpperCase();
            // const word = el.currentWordInput.value.toUpperCase();
            if (word.length < gameData.minWordLength) { 
                alert(`Word must be at least ${gameData.minWordLength} letters long.`); 
                return; 
            }
            const myCurrentWords = playerWords[userId]?.[gameData.round] || [];
            // if (myCurrentWords.includes(word)) { 
            //     alert("You have already submitted this word."); 
            //     clearCurrentWord(); 
            //     return; 
            // }
            try { 
                const wordsRef = doc(db, `artifacts/${appId}/public/data/games/${gameId}/playerWords`, userId); 
                const roundField = String(gameData.round);
                await setDoc(wordsRef, { [roundField]: arrayUnion(word) }, { merge: true });
                clearCurrentWord(); 
            } catch(error) { 
                console.error("Error submitting word:", error); 
            }
        }
        
        function handleDieClick(dieEl, letter, row, col) { 
            if (!dieEl || currentWord.some(d => d.row === row && d.col === col)) return; 
            // currentWord.push({ letter, row, col }); 
            currentWord.push({ letter, row, col, el: dieEl }); // Store the element reference
            dieEl.classList.add('selected'); 
            renderCurrentWord(); 
        }
        
        async function validateWord(word, filters) {
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (!response.ok) return { isValid: false }; 
                const data = await response.json();
                const entry = data[0];
                if (!entry) return { isValid: false };
                let passesFilters = true;
                if (filters.includes('no-plurals')) {
                     if (word.toLowerCase().endsWith('s') && entry.word.toLowerCase() !== word.toLowerCase()) {
                        const singularForm = word.slice(0, -1);
                        if (entry.word.toLowerCase() === singularForm.toLowerCase()) { passesFilters = false; }
                     }
                }
                const partsOfSpeech = new Set(entry.meanings.map(m => m.partOfSpeech));
                const posFilters = filters.filter(f => f !== 'no-plurals');
                if (posFilters.length > 0 && !posFilters.some(f => partsOfSpeech.has(f))) { passesFilters = false; }
                return { isValid: passesFilters };
            } catch (error) { return { isValid: false }; }
        }
        
        async function calculateScores(isFinal = false) {
            if (userId !== gameData.hostId) return null;

            const allWordsDocs = await getDocs(collection(db, `artifacts/${appId}/public/data/games/${gameId}/playerWords`));
            const allPlayerWords = {};
            allWordsDocs.forEach(doc => { allPlayerWords[doc.id] = doc.data() || {}; });
            
            const currentRoundWordsByPlayer = {};
            Object.keys(allPlayerWords).forEach(pid => { currentRoundWordsByPlayer[pid] = allPlayerWords[pid][gameData.round] || []; });
            
            const allWordsInRound = [...new Set(Object.values(currentRoundWordsByPlayer).flat())]; 
            const validationPromises = allWordsInRound.map(word => validateWord(word, gameData.wordFilters || []));
            const validationResults = await Promise.all(validationPromises);
            
            const initialValidWords = allWordsInRound.filter((_, index) => validationResults[index].isValid);
            const overrides = gameData.roundOverrides?.[gameData.round] || {};
            
            let finalValidWords = new Set(initialValidWords);
            for(const word in overrides) {
                if (overrides[word]) finalValidWords.add(word);
                else finalValidWords.delete(word);
            }
            const validWordsList = [...finalValidWords];
            
            const wordCounts = Object.values(currentRoundWordsByPlayer).flat().reduce((acc, word) => { acc[word] = (acc[word] || 0) + 1; return acc; }, {});
            
            const updatedPlayers = { ...gameData.players };
            Object.keys(currentRoundWordsByPlayer).forEach(pid => {
                let roundScore = 0;
                const isSinglePlayer = Object.keys(gameData.players).length === 1;
                currentRoundWordsByPlayer[pid].forEach(word => {
                    const isUnique = wordCounts[word] === 1;
                    // if (validWordsList.includes(word) && (isSinglePlayer || isUnique)) {
                    //     roundScore += word.length;
                    // }
                    const isLongEnough = word.length >= gameData.minWordLength; 

                    // --- AND UPDATE THIS LINE ---
                    if (validWordsList.includes(word) && isLongEnough && (isSinglePlayer || isUnique)) {
                        roundScore += word.length;
                    }
                });

                if (updatedPlayers[pid]) {
                    let totalScore = 0;
                    for (const round in updatedPlayers[pid].history) {
                        if (parseInt(round) !== gameData.round) {
                            totalScore += updatedPlayers[pid].history[round];
                        }
                    }
                    totalScore += roundScore;
                    
                    updatedPlayers[pid].score = totalScore;
                    updatedPlayers[pid].roundScore = roundScore; 
                    updatedPlayers[pid].history[gameData.round] = roundScore; 
                }
            });

            const updatePayload = { players: updatedPlayers };
            if (isFinal) {
                updatePayload[`validWordsByRound.${gameData.round}`] = validWordsList;
            }

            await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), updatePayload);
        }
        
        // --- Rendering Functions ---
        function renderGame(oldStatus) { 
            el.howToPlayBtn.classList.remove('hidden');
            // Handle view transitions based on status changes
            switch(gameData.status) {
                case 'waiting':
                    el.readyCheckModalBg.classList.add('hidden');
                    el.countdownOverlay.classList.add('hidden');
                    el.micBtn.classList.remove('hidden');
                    break;
                case 'ready-check':
                    el.readyCheckModalBg.classList.remove('hidden');
                    renderReadyCheckModal();
                    el.micBtn.classList.remove('hidden');
                    break;
                case 'starting':
                     if (oldStatus !== 'starting') {
                        el.readyCheckModalBg.classList.add('hidden');
                        showCountdownAnimation();
                     }
                    break;
                case 'playing':
                    if(oldStatus !== 'playing'){
                        clearCurrentWord();
                        el.myWordsList.innerHTML = '';
                        el.micBtn.classList.remove('hidden');
                    }
                    el.countdownOverlay.classList.add('hidden');
                    break;
                case 'scoring':
                     if (oldStatus !== 'scoring') {
                        showScoringModal();
                    } else if (!el.scoringModal.classList.contains('hidden')) {
                        showScoringModal();
                    }
                    el.micBtn.classList.remove('hidden');
                    break;
            }

            renderLayout(); 
            renderLeaderboard(); 
            renderGameInfoControls(); 
            renderTimerAndStatus(); 
            renderGrid(); 
            renderButtons(); 
        }

        // function renderLayout() { 
        //     const isPlaying = gameData?.status === 'playing' || gameData?.status === 'paused';
        //     el.leftPanel.classList.toggle('panel-hidden', isPlaying && !el.leftPanel.classList.contains('force-show')); 
        //     el.rightPanel.classList.toggle('panel-hidden', false);
        //     el.showPanelsBtn.classList.toggle('hidden', !isPlaying);
        //     if (!isPlaying) el.leftPanel.classList.remove('force-show');
        // }
        // function renderLayout() {
        //     const isPlaying = gameData?.status === 'playing' || gameData?.status === 'paused';
        //     const isSmallScreen = window.innerWidth < 1024;

        //     // Set the main container's flex direction based on screen size
        //     if (isSmallScreen) {
        //         el.gameView.classList.add('flex-col');
        //         el.gameView.classList.remove('lg:flex-row');
        //     } else {
        //         el.gameView.classList.remove('flex-col');
        //         el.gameView.classList.add('lg:flex-row');
        //     }

        //     // Always ensure the panels are visible by default unless they should be hidden
        //     el.leftPanel.classList.remove('hidden', 'panel-hidden');
        //     el.rightPanel.classList.remove('hidden', 'panel-hidden');

        //     if (isPlaying) {
        //         el.showPanelsBtn.classList.remove('hidden');
        //         // On small screens, hide both panels if not forced to show
        //         if (isSmallScreen) {
        //             if (!el.leftPanel.classList.contains('force-show')) {
        //                 el.leftPanel.classList.add('hidden');
        //                 el.rightPanel.classList.add('hidden');
        //             }
        //             el.showPanelsBtn.textContent = 'Info/Words';
        //         } else {
        //             // On large screens, only hide the left panel
        //             if (!el.leftPanel.classList.contains('force-show')) {
        //                 el.leftPanel.classList.add('panel-hidden');
        //             }
        //             el.showPanelsBtn.textContent = 'Show Info';
        //         }
        //     } else {
        //         // If not playing, always show all panels and hide the toggle button
        //         el.showPanelsBtn.classList.add('hidden');
        //         el.leftPanel.classList.remove('force-show');
        //     }
        // }
        function renderLayout() { 
            // This function is intentionally left mostly empty.
            // The main layout is now handled by the responsive Tailwind CSS classes 
            // on the #game-view div, ensuring it remains consistent.
            const isPlaying = gameData?.status === 'playing' || gameData?.status === 'paused';
            // We only need to toggle the mic button's visibility here.
            if(el.micBtn) {
                el.micBtn.classList.toggle('hidden', !isPlaying);
            }
        }

        // Also, make sure to add a resize listener to re-evaluate the layout
        window.addEventListener('resize', renderLayout);

        // function togglePanels() { 
        //     el.leftPanel.classList.toggle('force-show'); 
        //     renderLayout(); 
        // }
        // function togglePanels() {
        //     const isSmallScreen = window.innerWidth < 1024;
        //     el.leftPanel.classList.toggle('force-show'); // Keep track of the user's intent

        //     if (isSmallScreen) {
        //         // On small screens, toggling shows/hides both side panels
        //         el.leftPanel.classList.toggle('hidden');
        //         el.rightPanel.classList.toggle('hidden');
        //     }
        //     // Re-run the main layout logic to apply changes correctly
        //     renderLayout();
        // }

        function renderLeaderboard() { 
            if (!gameData || !gameData.players) { 
                el.leaderboard.innerHTML = '<p>No players yet.</p>'; 
                return; 
            } 
            const playersArray = Object.entries(gameData.players).map(([id, data]) => ({ id, ...data, isHost: id === gameData.hostId })); 
            playersArray.sort((a, b) => b.score - a.score); 
            el.leaderboard.innerHTML = `<table class="w-full text-left"><thead><tr class="border-b-2"><th class="py-2 font-semibold">Player</th><th class="py-2 text-center">Round</th><th class="py-2 text-center">Total</th></tr></thead><tbody>${playersArray.map(p => `<tr class="border-b"><td class="py-2">${p.name} ${p.id === userId ? '(You)' : ''} ${p.isHost ? 'ðŸ‘‘' : ''}</td><td class="py-2 text-center">${p.roundScore}</td><td class="py-2 text-center font-bold">${p.score}</td></tr>`).join('')}</tbody></table>`; 
        }

        // function renderGameInfoControls() { 
        //     if (!gameData) return; 
        //     const isHost = userId === gameData.hostId; 
        //     el.gameInfoControls.innerHTML = `<h2 class="text-2xl font-bold text-gray-700 mb-4">Game Info</h2><div><label class="font-semibold">Game ID:</label><div class="flex items-center gap-2 mt-1"><input id="game-id-display-ingame" type="text" readonly class="w-full bg-gray-100 px-3 py-2 border rounded-lg" value="${gameId}"><button id="copy-game-id-btn-ingame" class="bg-gray-200 p-2 rounded-lg"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z"></path><path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z"></path></svg></button></div></div>${isHost ? `<div id="host-controls" class="mt-4 space-y-2"><button id="start-next-round-btn-ingame" class="w-full bg-green-500 text-white font-bold py-2 px-4 rounded-lg"></button><button id="pause-resume-btn-ingame" class="w-full bg-orange-500 text-white font-bold py-2 px-4 rounded-lg"></button><button id="restart-game-btn-ingame" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg">End & Restart Game</button></div>` : ''}`; 
        //     if (isHost) { 
        //         document.getElementById('start-next-round-btn-ingame')?.addEventListener('click', handleStartGame); 
        //         document.getElementById('pause-resume-btn-ingame')?.addEventListener('click', handlePauseResumeGame); 
        //         document.getElementById('restart-game-btn-ingame')?.addEventListener('click', handleRestartGame); 
        //     } 
        //     document.getElementById('copy-game-id-btn-ingame')?.addEventListener('click', () => handleCopyGameId(gameId));
        // }
        function renderGameInfoControls() { 
            if (!gameData) return; 
            const isHost = userId === gameData.hostId; 
            const showSettings = isHost && (gameData.status === 'waiting' || gameData.status === 'scoring');

            el.gameInfoControls.innerHTML = `
                <h2 class="text-2xl font-bold text-gray-700 mb-4">Game Info</h2>
                <div>
                    <label class="font-semibold">Game ID:</label>
                    <div class="flex items-center gap-2 mt-1">
                        <input id="game-id-display-ingame" type="text" readonly class="w-full bg-gray-100 px-3 py-2 border rounded-lg" value="${gameId}">
                        <button id="copy-game-id-btn-ingame" class="bg-gray-200 p-2 rounded-lg"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z"></path><path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z"></path></svg></button>
                    </div>
                </div>
                ${isHost ? `
                    <div id="host-controls" class="mt-4 space-y-2">
                        <div id="host-settings" class="${showSettings ? '' : 'hidden'}">
                            <h3 class="text-xl font-bold text-gray-700 mt-4 mb-2">Next Round Settings</h3>
                            <div class="grid grid-cols-2 gap-4 mb-4">
                                <div>
                                    <label for="timer-setting-ingame" class="font-semibold text-gray-600">Time (s):</label>
                                    <input type="number" id="timer-setting-ingame" value="${gameData.timerDuration}" class="w-full mt-1 px-3 py-2 border border-gray-300 rounded-lg">
                                </div>
                                <div>
                                    <label for="min-word-length-ingame" class="font-semibold text-gray-600">Min Length:</label>
                                    <input type="number" id="min-word-length-ingame" value="${gameData.minWordLength}" class="w-full mt-1 px-3 py-2 border border-gray-300 rounded-lg">
                                </div>
                            </div>
                        </div>
                        <button id="start-next-round-btn-ingame" class="w-full bg-green-500 text-white font-bold py-2 px-4 rounded-lg"></button>
                        <button id="pause-resume-btn-ingame" class="w-full bg-orange-500 text-white font-bold py-2 px-4 rounded-lg"></button>
                        <button id="restart-game-btn-ingame" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg">End & Restart Game</button>
                    </div>` : ''}
            `; 
            
            if (isHost) { 
                document.getElementById('start-next-round-btn-ingame')?.addEventListener('click', handleStartGame); 
                document.getElementById('pause-resume-btn-ingame')?.addEventListener('click', handlePauseResumeGame); 
                document.getElementById('restart-game-btn-ingame')?.addEventListener('click', handleRestartGame); 
            } 
            document.getElementById('copy-game-id-btn-ingame')?.addEventListener('click', () => handleCopyGameId(gameId));
        }
        
        function renderTimerAndStatus() {
            if (!gameData) return;
            const { status, timer, round } = gameData;
            clearInterval(timerInterval);

            if (status === 'playing' && userId === gameData.hostId) {
                timerInterval = setInterval(async () => {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
                    const gameDocSnap = await getDoc(gameRef);
                    if(!gameDocSnap.exists()) {
                        clearInterval(timerInterval);
                        return;
                    }
                    const currentTimer = gameDocSnap.data().timer;
                    if (currentTimer > 0) {
                        await updateDoc(gameRef, { timer: currentTimer - 1 });
                    } else {
                        clearInterval(timerInterval);
                        // await calculateScores(true);
                        // await updateDoc(gameRef, { status: 'scoring' });
                        // Just set the status. The host's listener will handle the calculation.
                        await updateDoc(gameRef, { status: 'calculating' });
                    }
                }, 1000);
            }

            el.timerDisplay.textContent = formatTime(timer || 0);
            if (status === 'playing') {
                el.gameStatusDisplay.textContent = `Round ${round}`;
            } else if (status === 'paused') {
                el.gameStatusDisplay.textContent = `Game Paused`;
            }else if (status === 'calculating') { // <-- Add this condition
                el.gameStatusDisplay.textContent = 'Calculating scores...';
            } else if (status === 'scoring') {
                el.gameStatusDisplay.textContent = `Round ${round} Over! Reviewing scores...`;
            } else if (status === 'waiting' || status === 'ready-check') {
                el.timerDisplay.textContent = formatTime(gameData.timerDuration || 120);
                el.gameStatusDisplay.textContent = status === 'ready-check' ? "Players are getting ready..." : "Waiting for host...";
            }
        }
        
        function renderGrid() {
            const { status, gridSize } = gameData; 
            let grid;
            try { grid = typeof gameData.grid === 'string' ? JSON.parse(gameData.grid) : []; } catch (e) { grid = []; }
            el.gameGrid.innerHTML = ''; 
            const size = gridSize || 4;
            el.gameGrid.style.gridTemplateColumns = `repeat(${size}, minmax(0, 1fr))`;
            
            if (status !== 'playing' && grid && grid.length > 0) {
                 grid.forEach((row, r) => { row.forEach((letter, c) => { 
                    const dieEl = document.createElement('button'); 
                    dieEl.className = 'die flex items-center justify-center text-2xl md:text-3xl font-bold uppercase bg-white rounded-lg opacity-70 cursor-not-allowed'; 
                    dieEl.textContent = letter;
                    dieEl.disabled = true;
                    el.gameGrid.appendChild(dieEl); 
                }); });
            } else if (status === 'playing' && grid && grid.length > 0) {
                grid.forEach((row, r) => { row.forEach((letter, c) => { 
                    const dieEl = document.createElement('button'); 
                    dieEl.className = 'die flex items-center justify-center text-2xl md:text-3xl font-bold uppercase bg-white rounded-lg cursor-pointer hover:bg-indigo-100'; 
                    dieEl.textContent = letter; dieEl.dataset.row = r; dieEl.dataset.col = c; 
                    dieEl.onclick = () => handleDieClick(dieEl, letter, r, c); 
                    el.gameGrid.appendChild(dieEl); }); });
            } else {
                 el.gameGrid.innerHTML = Array.from({length: size * size}).map(() => `<div class="aspect-square bg-gray-200 rounded-lg animate-pulse"></div>`).join(''); 
            }
        }
        
        function renderButtons() {
            if (!gameData || !gameData.players) return;
            const { status, hostId, round } = gameData;
            const isHost = userId === hostId;
            if (isHost && document.getElementById('host-controls')) {
                const startNextBtn = document.getElementById('start-next-round-btn-ingame');
                const pauseResumeBtn = document.getElementById('pause-resume-btn-ingame');
                const restartBtn = document.getElementById('restart-game-btn-ingame');
                if (startNextBtn) { startNextBtn.classList.toggle('hidden', status === 'playing' || status === 'paused' || status === 'ready-check'); startNextBtn.textContent = (round || 0) === 0 ? 'Start Game' : 'Start Next Round';}
                if(pauseResumeBtn) { const isPausable = (status === 'playing' || status === 'paused'); pauseResumeBtn.classList.toggle('hidden', !isPausable); if(isPausable) pauseResumeBtn.textContent = status === 'playing' ? 'Pause' : 'Resume'; }
                if(restartBtn) restartBtn.classList.toggle('hidden', status === 'playing' || status === 'paused' || status === 'ready-check');
            }
            const isPlaying = status === 'playing'; el.submitWordBtn.disabled = !isPlaying; el.clearWordBtn.disabled = !isPlaying;
        }

        function renderCurrentWord() { el.currentWordInput.value = currentWord.map(w => w.letter).join(''); }
        function renderMyWords() { 
            const myWords = playerWords[userId]?.[gameData.round] || []; 
            el.myWordsList.innerHTML = myWords.map(word => `<li class="p-2 bg-white rounded shadow-sm mb-2">${word}</li>`).join(''); 
            el.myWordsList.scrollTop = el.myWordsList.scrollHeight; 
        }
        
        async function showDefinition(word) {
            el.dictionaryWord.textContent = 'Loading...'; 
            el.dictionaryDefinition.innerHTML = '';
            bringToFront(el.dictionaryModal);
            el.dictionaryModal.classList.remove('hidden');
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                el.dictionaryWord.textContent = word;
                if (!response.ok) { 
                    el.dictionaryDefinition.textContent = "No definition found."; 
                    return; 
                }
                const data = await response.json();
                el.dictionaryDefinition.innerHTML = ''; // Clear loading
                data[0].meanings.forEach(meaning => {
                    const partOfSpeech = document.createElement('strong'); 
                    partOfSpeech.className = "block mt-2 capitalize font-bold"; 
                    partOfSpeech.textContent = meaning.partOfSpeech;
                    el.dictionaryDefinition.appendChild(partOfSpeech);
                    const definitionsList = document.createElement('ul'); 
                    definitionsList.className = 'list-disc list-inside space-y-1';
                    meaning.definitions.forEach(def => { 
                        const li = document.createElement('li'); 
                        li.textContent = def.definition; 
                        definitionsList.appendChild(li); 
                    });
                    el.dictionaryDefinition.appendChild(definitionsList);
                });
            } catch (error) { 
                el.dictionaryWord.textContent = word; 
                el.dictionaryDefinition.textContent = "Error fetching definition."; 
            }
        }
        
        function hideDefinition() { el.dictionaryModal.classList.add('hidden'); }

        async function showScoringModal() {
            localOverrides = {}; 
            el.scoringHostControls.classList.toggle('hidden', userId !== gameData.hostId);
            el.editScoresToggle.checked = false;
            el.scoringModalContent.classList.remove('edit-mode');
            el.applyOverridesBtn.classList.add('hidden');
            el.revealTopWordsBtn.disabled = false;
            
            const validWordsForRound = gameData.validWordsByRound?.[gameData.round] || [];
            
            el.scoringModalContent.innerHTML = '<div class="col-span-full text-center">Loading scores...</div>';

            const allWordsDocs = await getDocs(collection(db, `artifacts/${appId}/public/data/games/${gameId}/playerWords`));
            const allWords = {};
            allWordsDocs.forEach(doc => { allWords[doc.id] = doc.data() || {}; });
            
            el.scoringModalContent.innerHTML = '';
            const sortedPlayers = Object.entries(gameData.players).sort(([,a], [,b]) => b.roundScore - a.roundScore);

            for (const [pid, player] of sortedPlayers) {
                const words = allWords[pid]?.[gameData.round] || [];
                const playerCard = document.createElement('div');
                playerCard.className = 'border rounded-lg p-4 bg-gray-50 flex flex-col';
                playerCard.innerHTML = `<h3 class="player-score-header font-bold text-xl mb-3">${player.name} - ${player.roundScore} pts</h3><ul class="space-y-1 h-48 overflow-y-auto pr-2 flex-grow"></ul>`;
                const wordListEl = playerCard.querySelector('ul');

                if (words.length === 0) { 
                    wordListEl.innerHTML = '<li class="text-gray-400">No words submitted.</li>'; 
                } else {
                    const wordCounts = Object.values(allWords).flatMap(pWords => pWords[gameData.round] || []).reduce((acc, word) => { acc[word] = (acc[word] || 0) + 1; return acc; }, {});
                    
                    words.sort().forEach(word => {
                        const isUnique = wordCounts[word] === 1;
                        const isWordValid = validWordsForRound.includes(word);
                        const points = isWordValid && (isUnique || Object.keys(gameData.players).length === 1) ? word.length : 0;
                        
                        const li = document.createElement('li');
                        li.className = `flex justify-between items-center p-1 rounded word-list-item`;
                        li.dataset.word = word;
                        
                        let validityClass = 'text-gray-500 line-through'; let pointText = '0';
                        if (points > 0) { validityClass = 'font-semibold text-green-600'; pointText = `+${points}`; } 
                        else if (isWordValid && !isUnique) { validityClass = 'text-yellow-600'; pointText = '0'; }
                        
                        li.innerHTML = `
                            <span class="word-text cursor-pointer hover:underline">${word}</span>
                            <div class="flex items-center gap-2">
                                <span class="word-points ${validityClass}">${pointText}</span>
                                <button class="host-override-btn text-lg text-green-500 hover:text-green-700" data-action="approve">ðŸ‘</button>
                                <button class="host-override-btn text-lg text-red-500 hover:text-red-700" data-action="reject">ðŸ‘Ž</button>
                            </div>
                        `;
                        
                        li.querySelector('.word-text').addEventListener('click', () => showDefinition(word));
                        li.querySelectorAll('.host-override-btn').forEach(btn => btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const action = e.target.dataset.action;
                            localOverrides[word] = (action === 'approve');
                            
                            li.classList.remove('word-overridden-approve', 'word-overridden-reject');
                            const pointSpan = li.querySelector('.word-points');
                            if (action === 'approve') {
                                li.classList.add('word-overridden-approve');
                                pointSpan.className = 'word-points font-semibold text-green-600';
                                pointSpan.textContent = `+${word.length}`;
                            } else {
                                li.classList.add('word-overridden-reject');
                                pointSpan.className = 'word-points text-gray-500 line-through';
                                pointSpan.textContent = '0';
                            }
                        }));
                        wordListEl.appendChild(li);
                    });
                }
                el.scoringModalContent.appendChild(playerCard);
            }
            bringToFront(el.scoringModal);
            el.scoringModal.classList.remove('hidden');
        }

        async function showStandingsModal() {
            const content = el.standingsModalContent; content.innerHTML = '<div class="text-center">Loading...</div>';
            let table = `<table class="w-full text-left table-fixed"><thead class="bg-gray-100"><tr><th class="p-2 w-1/3">Player</th>`;
            const rounds = Array.from({length: gameData.round || 0}, (_, i) => i + 1);
            rounds.forEach(r => { table += `<th class="p-2 text-center cursor-pointer hover:bg-gray-200 round-history-btn" data-round="${r}">R${r}</th>`});
            table += `<th class="p-2 text-center font-bold">Total</th></tr></thead><tbody>`;
            const players = Object.values(gameData.players).sort((a, b) => b.score - a.score);
            players.forEach(p => {
                table += `<tr class="border-b"><td class="p-2 font-semibold">${p.name}</td>`;
                rounds.forEach(r => { table += `<td class="p-2 text-center">${p.history[r] || 0}</td>` });
                table += `<td class="p-2 text-center font-bold">${p.score}</td></tr>`;
            });
            table += `</tbody></table><div id="round-words-view" class="mt-4 p-4 bg-gray-50 rounded hidden"></div>`;
            content.innerHTML = table;
            content.querySelectorAll('.round-history-btn').forEach(btn => btn.addEventListener('click', async (e) => {
                const roundNum = e.target.dataset.round;
                const wordView = document.getElementById('round-words-view');
                wordView.classList.remove('hidden');
                wordView.innerHTML = `<h3 class="text-xl font-bold mb-2">Words from Round ${roundNum}</h3><div class="text-center">Loading words...</div>`;
                const allWordsDocs = await getDocs(collection(db, `artifacts/${appId}/public/data/games/${gameId}/playerWords`));
                const allWordsData = {};
                allWordsDocs.forEach(doc => { allWordsData[doc.id] = doc.data() || {}; });
                wordView.innerHTML = `<h3 class="text-xl font-bold mb-2">Words from Round ${roundNum}</h3>`;
                for(const pid in gameData.players) {
                    const pName = gameData.players[pid].name; const words = allWordsData[pid]?.[roundNum] || [];
                    const playerWordsDiv = document.createElement('div'); playerWordsDiv.className = 'mb-2';
                    playerWordsDiv.innerHTML = `<strong class="font-semibold">${pName}:</strong> `;
                    if (words.length > 0) { words.forEach((word, index) => { const wordSpan = document.createElement('span'); wordSpan.className = 'cursor-pointer text-blue-600 hover:underline'; wordSpan.textContent = word; wordSpan.onclick = () => showDefinition(word); playerWordsDiv.appendChild(wordSpan); if (index < words.length - 1) playerWordsDiv.append(', '); });
                    } else { playerWordsDiv.append('None'); }
                    wordView.appendChild(playerWordsDiv);
                }
            }));
            bringToFront(el.standingsModal);
            el.standingsModal.classList.remove('hidden');
        }

        async function getTopWordsFromGemini(gridLetters, filters, round) {
            const systemPrompt = `You are an expert lexicographer for a word game. Your task is to identify the highest-scoring valid English words that can be constructed from a given set of letters.
                                    The Objective is to suggest user unique words for their growth and learning.
                                    Constraints:
                                    1. All generated words must be valid English dictionary words and unique.
                                    2. Given a word, points are awarded based on the length of the word (1 point per letter).
                                    3. You will be given an array of single-character english alphabets strings (the 'grid letters').
                                    4. You can only use each letter from the input array once per word.
                                    5. The generated words must match one of the provided part-of-speech filters, if any are provided. 
                                    6. The word must be atmost 6 letters long.
                                    7. You must not generat plural forms of words having 's' or 'es' or past tense forms ending with 'ed'.
                                    8. Prioritize longer words as they score more points.
                                    Output Format:
                                    Your response must be a single, valid JSON object. The object should contain a single key, "topWords", which is an array of objects. Each object in the array should have two keys: "word" (the generated word as a string) and "score" (the word's length as an integer). Provide up to 10 of the highest-scoring words. If fewer than 10 words can be formed, return as many as you can find. If no valid words can be formed, return an empty array.`;

            const userPrompt = JSON.stringify({ letters: gridLetters, minLength: gameData.minWordLength, filters: filters });

            const payload = {
                contents: [{ role: "user", parts: [{ text: `${systemPrompt}\n\nHere is the request:\n${userPrompt}` }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            topWords: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        word: { type: "STRING" },
                                        score: { type: "NUMBER" },
                                    },
                                    required: ["word", "score"],
                                },
                            },
                        },
                        required: ["topWords"],
                    },
                },
            };

            const apiKey = "AIzaSyB3ngRcUo2C2Y1Us6lmQWKiGrGRodXI6-Q"; // API Key is handled by the environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();

                if (result.candidates && result.candidates[0]?.content?.parts[0]?.text) {
                    try {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        const data = JSON.parse(jsonText);
                        
                        if (data.topWords) {
                             await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), {
                                [`topWordsByRound.${round}`]: data.topWords
                             });
                        }
                    } catch (e) {
                         console.error("Error parsing JSON response from Gemini:", e);
                         console.error("Received text that failed to parse:", result.candidates[0].content.parts[0].text);
                    }
                } else {
                    console.error("No valid candidate text returned from Gemini API.", result);
                }
            } catch (error) {
                console.error("Error during Gemini API fetch:", error);
            }
        }

        function handleRevealTopWords() {
            el.topWordsContent.innerHTML = '';
            const topWords = gameData.topWordsByRound?.[gameData.round];

            if (topWords && topWords.length > 0) {
                 el.topWordsContent.innerHTML = `<ul class="space-y-2">${topWords.map(item => `<li class="flex justify-between items-center p-2 bg-gray-100 rounded"><button data-word="${item.word}" class="font-bold uppercase hover:underline">${item.word}</button><span>${item.score} pts</span></li>`).join('')}</ul>`;
                 el.topWordsContent.querySelectorAll('button[data-word]').forEach(btn => {
                    btn.addEventListener('click', () => showDefinition(btn.dataset.word));
                });
            } else {
                el.topWordsContent.innerHTML = '<p class="text-center">Top words are being generated. Please try again in a moment.</p>';
            }
            el.topWordsModal.classList.remove('hidden');
            bringToFront(el.topWordsModal);
        }
        
        // function handleKeyDown(event) {
        //     if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
        //     if (gameData?.status !== 'playing') return;
        //     if (event.key === 'Enter') { 
        //         event.preventDefault(); 
        //         handleSubmitWord(); 
        //     } else if (event.key === 'Backspace') { 
        //         event.preventDefault();
        //         if(currentWord.length > 0){
        //             const lastDie = currentWord.pop();
        //             const dieEl = document.querySelector(`.die[data-row='${lastDie.row}'][data-col='${lastDie.col}']`);
        //             if(dieEl) dieEl.classList.remove('selected');
        //             renderCurrentWord();
        //         }
        //     } else if (/^[a-zA-Z]$/.test(event.key)) {
        //         event.preventDefault(); 
        //         const letter = event.key.toUpperCase();
                
        //         // Find the first available (unselected) die that matches the typed letter
        //         const availableDie = Array.from(document.querySelectorAll('#game-grid .die:not(.selected)')).find(d => d.textContent === letter);

        //         if (availableDie) {
        //             const { row, col } = availableDie.dataset;
        //             handleDieClick(availableDie, letter, parseInt(row), parseInt(col));
        //         }
        //     }
        // }
        function handleKeyDown(event) {
            // Prevent typing in the name input from triggering game actions
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                if (event.target.id === 'current-word-input' && event.key === 'Enter') {
                    event.preventDefault();
                    handleSubmitWord();
                }
                return;
            }

            if (gameData?.status !== 'playing') return;

            // Trigger mic with the Space bar
            if (event.code === 'Space') {
                event.preventDefault();
                handleMicClick();
                return; 
            }

            if (event.key === 'Enter') { 
                event.preventDefault(); 
                handleSubmitWord(); 
            } else if (event.key === 'Backspace') { 
                event.preventDefault();
                if(currentWord.length > 0){
                    const lastDie = currentWord.pop();
                    // The 'el' property holds the direct reference to the button element
                    if (lastDie.el) {
                        lastDie.el.classList.remove('selected');
                    }
                    renderCurrentWord();
                }
            } else if (/^[a-zA-Z]$/.test(event.key)) {
                event.preventDefault(); 
                const letter = event.key.toUpperCase();
                
                const allDice = Array.from(document.querySelectorAll('#game-grid .die'));
                let dieToSelect = null;

                // Loop through every single die on the grid in order
                for (const die of allDice) {
                    const row = parseInt(die.dataset.row);
                    const col = parseInt(die.dataset.col);

                    // Check if this specific die (by its coordinates) is already in our word
                    const isAlreadySelected = currentWord.some(d => d.row === row && d.col === col);

                    // If the letter matches AND this specific die hasn't been selected yet...
                    if (die.textContent === letter && !isAlreadySelected) {
                        dieToSelect = die; // ...we've found our target
                        break; // Stop searching and select this die
                    }
                }

                // If we found an available die, click it
                if (dieToSelect) {
                    const { row, col } = dieToSelect.dataset;
                    handleDieClick(dieToSelect, letter, parseInt(row), parseInt(col));
                }
            }
}
        
        // --- Modal Drag/Resize Utilities ---
        function bringToFront(modal) { highestZ++; modal.style.zIndex = highestZ; }
        function setupModal(modal) {
            const header = modal.querySelector('.modal-header'); const resizeHandle = modal.querySelector('.resize-handle');
            modal.addEventListener('mousedown', () => bringToFront(modal));
            if (header) makeDraggable(modal, header); if (resizeHandle) makeResizable(modal, resizeHandle);
        }
        function makeDraggable(element, header) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; header.onmousedown = dragMouseDown;
            function dragMouseDown(e) { e = e || window.event; e.preventDefault(); pos3 = e.clientX; pos4 = e.clientY; document.onmouseup = closeDragElement; document.onmousemove = elementDrag; }
            function elementDrag(e) { e = e || window.event; e.preventDefault(); pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; element.style.top = (element.offsetTop - pos2) + "px"; element.style.left = (element.offsetLeft - pos1) + "px"; }
            function closeDragElement() { document.onmouseup = null; document.onmousemove = null; }
        }
        function makeResizable(element, handle) {
            let initialWidth, initialHeight, initialX, initialY; handle.onmousedown = startResize;
            function startResize(e) { e.preventDefault(); initialWidth = element.offsetWidth; initialHeight = element.offsetHeight; initialX = e.clientX; initialY = e.clientY; document.onmousemove = resizeElement; document.onmouseup = stopResize; }
            function resizeElement(e) { const newWidth = initialWidth + (e.clientX - initialX); const newHeight = initialHeight + (e.clientY - initialY); if (newWidth > 300) element.style.width = newWidth + 'px'; if (newHeight > 200) element.style.height = newHeight + 'px'; }
            function stopResize() { document.onmousemove = null; document.onmouseup = null; }
        }
        
        // --- General Utilities ---
        function clearCurrentWord() { currentWord = []; renderCurrentWord(); document.querySelectorAll('.die.selected').forEach(el => el.classList.remove('selected')); }
        function formatTime(seconds) { const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
        function handleCopyGameId(id) { 
            if (navigator.clipboard) { navigator.clipboard.writeText(id).then(() => { alert('Game ID copied!'); }, () => { alert('Failed to copy.'); });
            } else { const input = document.createElement('textarea'); input.value = id; document.body.appendChild(input); input.select(); try { document.execCommand('copy'); alert('Game ID copied!'); } catch (err) { alert('Failed to copy.'); } document.body.removeChild(input); }
        }
        function listenForPlayerWords() {
            if (!gameData || !gameData.players) return; const playerIds = Object.keys(gameData.players);
            Object.keys(wordsUnsubscribe).forEach(pid => { if (!playerIds.includes(pid)) { wordsUnsubscribe[pid](); delete wordsUnsubscribe[pid]; }});
            playerIds.forEach(pid => { if (!wordsUnsubscribe[pid]) { const wordsRef = doc(db, `artifacts/${appId}/public/data/games/${gameId}/playerWords`, pid); wordsUnsubscribe[pid] = onSnapshot(wordsRef, (doc) => { playerWords[pid] = doc.data() || {}; if (pid === userId) renderMyWords(); });}});
        }
        
        function renderReadyCheckModal() {
            el.readyCheckList.innerHTML = '';
            
            clearTimeout(forceStartTimer);

            Object.entries(gameData.players).forEach(([pid, player]) => {
                const playerReadyDiv = document.createElement('div');
                playerReadyDiv.className = 'flex items-center justify-between bg-gray-100 p-3 rounded-lg';
                const isCurrentUser = pid === userId;

                playerReadyDiv.innerHTML = `
                    <label for="ready-check-${pid}" class="font-semibold ${isCurrentUser ? 'text-indigo-600' : ''}">${player.name} ${isCurrentUser ? '(You)' : ''}</label>
                    <input type="checkbox" id="ready-check-${pid}" class="h-6 w-6 rounded-md accent-indigo-500" ${player.isReady ? 'checked' : ''} ${!isCurrentUser ? 'disabled' : ''}>
                `;
                
                if (isCurrentUser) {
                    playerReadyDiv.querySelector(`#ready-check-${pid}`).addEventListener('change', async (e) => {
                        await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), {
                            [`players.${userId}.isReady`]: e.target.checked
                        });
                    });
                }
                
                el.readyCheckList.appendChild(playerReadyDiv);
            });
            
            const isHost = userId === gameData.hostId;
            el.forceStartBtn.classList.toggle('hidden', !isHost);
            if (isHost) {
                el.forceStartBtn.disabled = true;
                forceStartTimer = setTimeout(() => {
                    el.forceStartBtn.disabled = false;
                }, 4000);
            }
        }

        function showCountdownAnimation() {
            el.countdownOverlay.classList.remove('hidden');
            el.countdownOverlay.classList.add('flex');
            let count = 3;
            el.countdownOverlay.textContent = count;

            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    el.countdownOverlay.textContent = count;
                } else if (count === 0) {
                    el.countdownOverlay.textContent = 'GO!';
                } else {
                    clearInterval(interval);
                    el.countdownOverlay.classList.add('hidden');
                    if(userId === gameData.hostId){
                         updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), { status: 'playing' });
                    }
                }
            }, 1000);
        }

        // Close modal on outside click
        window.addEventListener('click', (e) => {
            if (!el.dictionaryModal.classList.contains('hidden') && !el.dictionaryModal.contains(e.target) && !e.target.closest('.word-text') && !e.target.closest('button[data-word]')) {
                hideDefinition();
            }
        });

    </script>
</body>
</html>
