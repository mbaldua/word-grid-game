<!-- deployement v7 - Patched with Welcome Modal -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Word Grid Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            overflow-x: hidden;
        }
        .die {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .die.selected {
            transform: scale(0.9) rotate(5deg);
            background-color: #fbbf24; /* amber-400 */
            color: #1f2937; /* gray-800 */
        }
        .modal-bg {
            background-color: rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s ease;
        }
       .modal-bg.hidden, .modal.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }
        .panel {
            transition: opacity 0.5s ease, transform 0.5s ease, width 0.5s ease;
        }
        .panel-hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
            width: 0 !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .word-list-item:hover {
            background-color: #e5e7eb;
        }
        .modal {
            position: fixed;
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            overflow: hidden; 
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .modal-header {
            cursor: move;
            background-color: #f9fafb; /* gray-50 */
            border-bottom: 1px solid #e5e7eb; /* gray-200 */
        }
        .resize-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            right: 0;
            bottom: 0;
            cursor: nwse-resize;
            background-image: linear-gradient(135deg, transparent 0%, transparent 50%, #6b7280 50%, #6b7280 100%);
        }
        .host-override-btn {
            display: none;
        }
        .edit-mode .host-override-btn {
            display: inline-block;
        }
        .word-overridden-approve {
            background-color: #dcfce7 !important; /* green-100 */
        }
        .word-overridden-reject {
            background-color: #fee2e2 !important; /* red-100 */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen">

    <div id="app-container" class="w-full max-w-7xl mx-auto p-4 flex flex-col items-center gap-6">
        <!-- Lobby View -->
        <div id="lobby-view" class="w-full hidden flex-col gap-6 items-center">
            <div class="w-full flex flex-col md:flex-row gap-6 justify-center">
                <!-- Create Game Panel -->
                <div id="create-game-panel" class="w-full md:w-1/2 bg-white p-6 rounded-2xl shadow-lg flex flex-col gap-4">
                     <h2 class="text-2xl font-bold text-gray-700">Create Game</h2>
                     <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="timer-setting" class="font-semibold text-gray-600">Time (s):</label>
                            <input type="number" id="timer-setting" value="45" min="30" max="300" class="w-full mt-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                        </div>
                        <div>
                            <label for="min-word-length" class="font-semibold text-gray-600">Min Length:</label>
                            <input type="number" id="min-word-length" value="3" min="2" max="10" class="w-full mt-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                        </div>
                    </div>
                     <div class="grid grid-cols-2 gap-4">
                         <div>
                            <label for="grid-size" class="font-semibold text-gray-600">Grid Size:</label>
                            <select id="grid-size" class="w-full mt-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                                <option value="4" selected>4x4</option>
                                <option value="5">5x5</option>
                                <option value="6">6x6</option>
                            </select>
                        </div>
                     </div>
                     <div>
                        <label class="font-semibold text-gray-600">Word Filters:</label>
                        <div class="flex flex-wrap gap-2 my-2" id="filter-tags-container"></div>
                        <div class="flex gap-2">
                            <input type="text" id="filter-input" placeholder="e.g., adjective" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                            <button id="add-filter-btn" class="bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600">+</button>
                        </div>
                    </div>
                    <button id="create-game-btn" class="w-full bg-green-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-600 transition-colors duration-300 shadow-md mt-auto">Create New Game</button>
                </div>
                <!-- Join Game Panel -->
                <div class="w-full md:w-1/2 bg-white p-6 rounded-2xl shadow-lg flex flex-col gap-4">
                     <h2 class="text-2xl font-bold text-gray-700">Join Game</h2>
                     <p class="text-gray-600">Ask a friend for their Game ID to join their room.</p>
                     <div class="flex gap-2 mt-auto">
                         <input type="text" id="join-game-id-input" placeholder="Enter Game ID" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 transition">
                         <button id="join-game-btn" class="bg-gray-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-gray-700 transition-colors duration-300 shadow-md">Join</button>
                     </div>
                     <div id="join-error-msg" class="text-red-500 text-sm mt-2 hidden"></div>
                </div>
            </div>
        </div>

        <!-- Game View -->
        <div id="game-view" class="w-full flex-row gap-6 hidden">
            <div id="left-panel" class="panel lg:w-1/4 bg-white p-6 rounded-2xl shadow-lg flex-col gap-6 order-2 lg:order-1 h-fit flex">
                <div id="game-info-controls"></div>
                <div id="leaderboard-summary" class="cursor-pointer">
                    <h2 class="text-2xl font-bold text-gray-700 mb-4 hover:text-indigo-600">Leaderboard ðŸ”Ž</h2>
                    <div id="leaderboard" class="space-y-2"></div>
                </div>
                 <div>
                    <h3 class="text-xl font-bold text-gray-700 mb-2">My User ID</h3>
                     <p id="user-id-display" class="text-xs text-gray-500 break-all"></p>
                </div>
            </div>

            <div id="center-panel" class="flex-grow bg-white p-6 rounded-2xl shadow-lg order-1 lg:order-2 flex flex-col items-center justify-center">
                 <div class="w-full flex items-center justify-between mb-4">
                    <div>
                         <button id="show-panels-btn" class="hidden bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300">Show Info</button>
                    </div>
                    <div class="text-center">
                        <div id="timer-display" class="text-6xl font-bold text-indigo-600">00:00</div>
                        <div id="game-status-display" class="text-lg text-gray-500 mt-1"></div>
                    </div>
                    <div class="w-28"></div>
                </div>
                <div id="game-grid" class="grid gap-2 aspect-square w-full max-w-lg"></div>
            </div>

            <div id="right-panel" class="panel lg:w-1/4 bg-white p-6 rounded-2xl shadow-lg flex-col gap-4 order-3 h-fit flex">
                 <div>
                    <h2 class="text-2xl font-bold text-gray-700 mb-4">Current Word</h2>
                    <div id="current-word-display" class="w-full h-16 bg-gray-100 rounded-lg flex items-center justify-center text-3xl font-semibold tracking-widest border-2 border-dashed"></div>
                    <div class="flex gap-2 mt-4">
                        <button id="submit-word-btn" class="flex-grow bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg">Submit</button>
                        <button id="clear-word-btn" class="bg-red-500 text-white font-bold py-3 px-4 rounded-lg">Clear</button>
                    </div>
                </div>
                <div>
                    <h2 class="text-2xl font-bold text-gray-700 mb-4">My Words</h2>
                    <ul id="my-words-list" class="h-64 overflow-y-auto bg-gray-50 p-3 rounded-lg border"></ul>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modals -->
     <div id="welcome-modal-bg" class="modal-bg fixed inset-0 z-40 flex items-center justify-center hidden">
        <div id="welcome-modal" class="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-sm flex flex-col gap-6">
            <h2 class="text-3xl font-bold text-center text-gray-800">Welcome!</h2>
            <div>
                <label for="player-name-modal" class="font-semibold text-gray-600">Choose Your Name:</label>
                <div class="flex gap-2 mt-1">
                    <input type="text" id="player-name-modal" placeholder="e.g., WordWizard" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                    <button id="suggest-name-btn" title="Suggest Name" class="bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300">ðŸ’¡</button>
                </div>
                 <p id="name-error-msg" class="text-red-500 text-sm mt-1 hidden">Please enter a name.</p>
            </div>
            <button id="enter-lobby-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 shadow-md">Enter Lobby</button>
        </div>
    </div>

    <div id="scoring-modal" class="modal hidden" style="width: 800px; height: 600px; top: 15%; left: 25%; z-index: 50;">
        <div id="scoring-modal-header" class="modal-header p-4 flex justify-between items-center"><h2 class="text-2xl font-bold text-center flex-grow">Round Over!</h2><button id="close-scoring-modal-btn" class="text-2xl font-bold">&times;</button></div>
        <div class="p-6 h-[calc(100%-60px)] flex flex-col">
            <div id="scoring-host-controls" class="hidden mb-4 p-3 border-b flex justify-between items-center bg-gray-50 rounded-lg">
                 <label class="flex items-center justify-center gap-2 font-semibold"><input type="checkbox" id="edit-scores-toggle" class="h-5 w-5 rounded"> Edit Scores (Host)</label>
                 <button id="apply-overrides-btn" class="hidden bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">Apply & Recalculate</button>
            </div>
            <div id="scoring-modal-content" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 overflow-y-auto flex-grow"></div>
            <div class="mt-4 text-center">
                <button id="reveal-top-words-btn" class="bg-purple-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-purple-700 disabled:bg-gray-400" disabled>Reveal Top Words ðŸ’¡</button>
            </div>
        </div>
        <div class="resize-handle"></div>
    </div>
    <div id="standings-modal" class="modal hidden" style="width: 900px; height: 700px; top: 10%; left: 20%; z-index: 50;">
        <div id="standings-modal-header" class="modal-header p-4 flex justify-between items-center"><h2 class="text-2xl font-bold">Standings & History</h2><button id="close-standings-modal-btn" class="text-2xl font-bold">&times;</button></div>
        <div id="standings-modal-content" class="p-6 overflow-y-auto h-[calc(100%-60px)]"></div>
        <div class="resize-handle"></div>
    </div>
    <div id="dictionary-modal" class="modal hidden" style="width: 450px; height: 500px; top: 20%; left: 35%; z-index: 60;">
        <div id="dictionary-modal-header" class="modal-header p-4 flex justify-between items-center"><h2 id="dictionary-word" class="text-2xl font-bold">Word</h2><button id="close-dictionary-btn" class="text-2xl font-bold">&times;</button></div>
        <div id="dictionary-definition" class="p-6 text-sm text-gray-700 overflow-y-auto h-[calc(100%-60px)]"></div>
        <div class="resize-handle"></div>
    </div>
    <div id="top-words-modal" class="modal hidden" style="width: 500px; height: 600px; top: 15%; left: 33%; z-index: 70;">
        <div id="top-words-modal-header" class="modal-header p-4 flex justify-between items-center"><h2 class="text-2xl font-bold">Top Possible Words</h2><button id="close-top-words-btn" class="text-2xl font-bold">&times;</button></div>
        <div id="top-words-content" class="p-6 overflow-y-auto h-[calc(100%-60px)]"></div>
        <div class="resize-handle"></div>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Use environment variables for Firebase config and App ID for security and flexibility.
        const firebaseConfig = {
          apiKey: "AIzaSyD_CHO-e69XJJh8NoD6fm4ih1YryuRCWeY",
          authDomain: "word-grid-game-live.firebaseapp.com",
          projectId: "word-grid-game-live",
          storageBucket: "word-grid-game-live.firebasestorage.app",
          messagingSenderId: "216890772517",
          appId: "1:216890772517:web:71d2d55f4adf295db043cc"
        };
        const appId = 'word-game';
        
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        // Game constants
        const DICE = ['A','A','E','E','G','N', 'A','B','B','J','O','O', 'A','C','H','O','P','S', 'A','F','F','K','P','S','A','O','O','T','T','W', 'C','I','M','O','T','U', 'D','E','I','L','R','X', 'D','E','L','R','V','Y','D','I','S','T','T','Y', 'E','E','G','H','N','W', 'E','E','I','N','S','U', 'E','H','R','T','V','W','E','I','O','S','S','T', 'E','L','R','T','T','Y', 'H','I','M','N','U','Q', 'H','L','N','N','R','Z'];
        const SUGGESTED_NAMES = ['LexiconLasso', 'WordWizard', 'GridGuru', 'AlphaAvenger', 'VowelViper', 'ConsonantKing', 'SyllableSlayer'];
        
        // State variables
        let userId = null, gameId = null, gameData = {}, playerWords = {}, currentWord = [], gameUnsubscribe = null, wordsUnsubscribe = {}, timerInterval = null;
        let highestZ = 70;
        let localOverrides = {};
        let playerName = '';

        // DOM element references
        const el = {
            lobbyView: document.getElementById('lobby-view'),
            gameView: document.getElementById('game-view'), 
            leftPanel: document.getElementById('left-panel'),
            rightPanel: document.getElementById('right-panel'), 
            createGameBtn: document.getElementById('create-game-btn'), 
            joinGameBtn: document.getElementById('join-game-btn'),
            joinGameIdInput: document.getElementById('join-game-id-input'), 
            joinErrorMsg: document.getElementById('join-error-msg'), 
            gameInfoControls: document.getElementById('game-info-controls'), 
            timerSetting: document.getElementById('timer-setting'), 
            minWordLength: document.getElementById('min-word-length'), 
            gridSize: document.getElementById('grid-size'), 
            filterInput: document.getElementById('filter-input'), 
            addFilterBtn: document.getElementById('add-filter-btn'), 
            filterTagsContainer: document.getElementById('filter-tags-container'),
            leaderboard: document.getElementById('leaderboard'), 
            leaderboardSummary: document.getElementById('leaderboard-summary'), 
            userIdDisplay: document.getElementById('user-id-display'),
            timerDisplay: document.getElementById('timer-display'), 
            gameStatusDisplay: document.getElementById('game-status-display'), 
            gameGrid: document.getElementById('game-grid'),
            currentWordDisplay: document.getElementById('current-word-display'), 
            submitWordBtn: document.getElementById('submit-word-btn'), 
            clearWordBtn: document.getElementById('clear-word-btn'),
            myWordsList: document.getElementById('my-words-list'), 
            scoringModal: document.getElementById('scoring-modal'), 
            scoringHostControls: document.getElementById('scoring-host-controls'),
            editScoresToggle: document.getElementById('edit-scores-toggle'), 
            scoringModalContent: document.getElementById('scoring-modal-content'), 
            closeScoringModalBtn: document.getElementById('close-scoring-modal-btn'), 
            dictionaryModal: document.getElementById('dictionary-modal'), 
            dictionaryWord: document.getElementById('dictionary-word'), 
            dictionaryDefinition: document.getElementById('dictionary-definition'), 
            closeDictionaryBtn: document.getElementById('close-dictionary-btn'), 
            showPanelsBtn: document.getElementById('show-panels-btn'), 
            standingsModal: document.getElementById('standings-modal'), 
            standingsModalContent: document.getElementById('standings-modal-content'), 
            closeStandingsModalBtn: document.getElementById('close-standings-modal-btn'),
            applyOverridesBtn: document.getElementById('apply-overrides-btn'),
            revealTopWordsBtn: document.getElementById('reveal-top-words-btn'),
            topWordsModal: document.getElementById('top-words-modal'),
            topWordsContent: document.getElementById('top-words-content'),
            closeTopWordsBtn: document.getElementById('close-top-words-btn'),
            // Welcome Modal elements
            welcomeModalBg: document.getElementById('welcome-modal-bg'),
            playerNameModalInput: document.getElementById('player-name-modal'),
            suggestNameBtn: document.getElementById('suggest-name-btn'),
            enterLobbyBtn: document.getElementById('enter-lobby-btn'),
            nameErrorMsg: document.getElementById('name-error-msg'),
        };

        // --- Authentication ---
        onAuthStateChanged(auth, async (user) => {
            if (user) { 
                userId = user.uid; 
                el.userIdDisplay.textContent = userId; 
                if (!playerName) {
                    el.welcomeModalBg.classList.remove('hidden');
                }
            } else { 
                try { 
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth); 
                    }
                } catch(error) { 
                    console.error("Sign-In Error:", error); 
                }
            }
        });
        
        // --- Event Listeners ---
        el.createGameBtn.addEventListener('click', handleCreateGame);
        el.joinGameBtn.addEventListener('click', handleJoinGame);
        el.submitWordBtn.addEventListener('click', handleSubmitWord);
        el.clearWordBtn.addEventListener('click', clearCurrentWord);
        el.closeScoringModalBtn.addEventListener('click', () => el.scoringModal.classList.add('hidden'));
        el.closeDictionaryBtn.addEventListener('click', hideDefinition);
        el.addFilterBtn.addEventListener('click', addFilterTag);
        el.filterInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addFilterTag(); });
        el.showPanelsBtn.addEventListener('click', togglePanels);
        el.leaderboardSummary.addEventListener('click', showStandingsModal);
        el.closeStandingsModalBtn.addEventListener('click', () => el.standingsModal.classList.add('hidden'));
        el.editScoresToggle.addEventListener('change', (e) => {
            el.scoringModalContent.classList.toggle('edit-mode', e.target.checked);
            el.applyOverridesBtn.classList.toggle('hidden', !e.target.checked);
            el.revealTopWordsBtn.disabled = e.target.checked;
        });
        el.applyOverridesBtn.addEventListener('click', handleApplyOverrides);
        el.revealTopWordsBtn.addEventListener('click', handleRevealTopWords);
        el.closeTopWordsBtn.addEventListener('click', () => el.topWordsModal.classList.add('hidden'));
        window.addEventListener('keydown', handleKeyDown);
        
        // New Modal Listeners
        el.enterLobbyBtn.addEventListener('click', handleEnterLobby);
        el.suggestNameBtn.addEventListener('click', suggestName);

        // --- Modal Setup ---
        setupModal(el.scoringModal);
        setupModal(el.standingsModal);
        setupModal(el.dictionaryModal);
        setupModal(el.topWordsModal);
        
        // --- Lobby Functions ---
        function getPlayerName() {
            return playerName || `Player_${crypto.randomUUID().substring(0, 4)}`;
        }

        function suggestName() {
            const baseName = SUGGESTED_NAMES[Math.floor(Math.random() * SUGGESTED_NAMES.length)];
            const randomNumber = Math.floor(100 + Math.random() * 900);
            el.playerNameModalInput.value = `${baseName}${randomNumber}`;
        }

        function handleEnterLobby() {
            const nameFromModal = el.playerNameModalInput.value.trim();
            if (!nameFromModal) {
                el.nameErrorMsg.classList.remove('hidden');
                return;
            }
            playerName = nameFromModal;
            el.nameErrorMsg.classList.add('hidden');
            el.welcomeModalBg.classList.add('hidden');
            el.lobbyView.classList.remove('hidden');
            el.lobbyView.classList.add('flex');
        }

        function createFilterTag(text) { 
            const tag = document.createElement('div'); 
            tag.className = "flex items-center bg-indigo-100 text-indigo-700 text-sm font-semibold px-3 py-1 rounded-full"; 
            tag.textContent = text; 
            const removeBtn = document.createElement('button'); 
            removeBtn.className = "ml-2 text-indigo-500 hover:text-indigo-700 font-bold"; 
            removeBtn.innerHTML = '&times;'; 
            removeBtn.onclick = () => tag.remove(); 
            tag.appendChild(removeBtn); 
            el.filterTagsContainer.appendChild(tag); 
        }

        function addFilterTag() { 
            const text = el.filterInput.value.trim().toLowerCase(); 
            if (text) { createFilterTag(text); el.filterInput.value = ''; }
        }

        ['noun', 'verb', 'adjective', 'no-plurals'].forEach(createFilterTag);

        async function handleCreateGame() {
            if (!userId) return;
            const newGameId = crypto.randomUUID().split('-')[0];
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, newGameId);
            const playerInfo = { name: getPlayerName(), score: 0, roundScore: 0, history: {} };
            const filters = Array.from(el.filterTagsContainer.children).map(tag => tag.firstChild.textContent.trim());
            try { 
                await setDoc(gameRef, { 
                    createdAt: new Date(), 
                    hostId: userId, 
                    status: 'waiting', 
                    timerDuration: parseInt(el.timerSetting.value, 10), 
                    minWordLength: parseInt(el.minWordLength.value, 10), 
                    gridSize: parseInt(el.gridSize.value, 10), 
                    wordFilters: filters, 
                    grid: '[]', 
                    players: { [userId]: playerInfo }, 
                    round: 0, 
                    validWordsByRound: {},
                    topWordsByRound: {},
                    roundOverrides: {} 
                }); 
                await joinGame(newGameId); 
            } catch (error) { console.error("Error creating game:", error); }
        }
        
        function handleJoinGame() { 
            el.joinErrorMsg.classList.add('hidden'); 
            const gameIdToJoin = el.joinGameIdInput.value.trim(); 
            if (gameIdToJoin) joinGame(gameIdToJoin); 
        }

        async function joinGame(id) {
            if (!userId) return;
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, id);
            try {
                const gameSnap = await getDoc(gameRef);
                if (!gameSnap.exists()) { 
                    el.joinErrorMsg.textContent = "Game not found. Please check the ID."; 
                    el.joinErrorMsg.classList.remove('hidden'); 
                    return; 
                }
                const game = gameSnap.data();

                if (gameUnsubscribe) gameUnsubscribe();
                Object.values(wordsUnsubscribe).forEach(unsub => unsub());
                wordsUnsubscribe = {}; 
                
                gameId = id;

                if (!game.players[userId]) { 
                    const playerInfo = { name: getPlayerName(), score: 0, roundScore: 0, history: {} }; 
                    await updateDoc(gameRef, { [`players.${userId}`]: playerInfo }); 
                }

                el.lobbyView.style.display = 'none'; 
                el.gameView.classList.remove('hidden'); 
                el.gameView.classList.add('flex');

                gameUnsubscribe = onSnapshot(gameRef, (doc) => { 
                    const oldStatus = gameData?.status;
                    gameData = doc.data(); 

                    if (gameData) { 
                        renderGame(); 
                        listenForPlayerWords(); 
                        
                        if (gameData.status === 'scoring' && oldStatus !== 'scoring') {
                            showScoringModal();
                        }
                        
                        if (gameData.status === 'scoring' && oldStatus === 'scoring') {
                            if (!el.scoringModal.classList.contains('hidden')) {
                                showScoringModal();
                            }
                        }

                        if (gameData.status === 'playing' && oldStatus !== 'playing') {
                            clearCurrentWord();
                            el.myWordsList.innerHTML = '';
                        }
                    }
                });
            } catch (error) { 
                console.error("Error joining game:", error); 
                el.joinErrorMsg.textContent = "An error occurred while joining the game."; 
                el.joinErrorMsg.classList.remove('hidden'); 
            }
        }
        
        // --- Host Controls ---
        async function handleStartGame() {
            if (!gameId || gameData.hostId !== userId) return;
            const currentRound = (gameData.round || 0) + 1;
            const size = gameData.gridSize;
            const shuffledDice = DICE.sort(() => 0.5 - Math.random());
            const newGrid = Array.from({ length: size }, (_, r) => Array.from({ length: size }, (_, c) => shuffledDice[(r * size + c) % shuffledDice.length]));
            
            const updatedPlayers = { ...gameData.players };
            Object.keys(updatedPlayers).forEach(pid => { updatedPlayers[pid].roundScore = 0; });
            
            const batch = writeBatch(db);
            Object.keys(gameData.players).forEach(pid => { 
                const wordsRef = doc(db, `artifacts/${appId}/public/data/games/${gameId}/playerWords`, pid); 
                batch.set(wordsRef, { [currentRound]: [] }, { merge: true }); 
            });
            await batch.commit();

            await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), { 
                status: 'playing', 
                grid: JSON.stringify(newGrid), 
                round: currentRound, 
                players: updatedPlayers, 
                timer: gameData.timerDuration, 
                [`roundOverrides.${currentRound}`]: {},
                [`validWordsByRound.${currentRound}`]: [],
                [`topWordsByRound.${currentRound}`]: [],
            });

            // Trigger Gemini API call in the background
            getTopWordsFromGemini(newGrid.flat(), gameData.wordFilters, currentRound);
        }
        
        async function handleRestartGame() { 
            if (!gameId || gameData.hostId !== userId) return; 
            location.reload(); 
        }

        async function handlePauseResumeGame() { 
            if (!gameId || gameData.hostId !== userId) return; 
            const newStatus = gameData.status === 'playing' ? 'paused' : 'playing'; 
            await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), { status: newStatus });
        }

        async function handleApplyOverrides() {
            if (userId !== gameData.hostId || Object.keys(localOverrides).length === 0) return;
            
            el.applyOverridesBtn.disabled = true;
            el.applyOverridesBtn.textContent = 'Applying...';
            
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            const currentOverrides = gameData.roundOverrides?.[gameData.round] || {};
            const newOverrides = { ...currentOverrides, ...localOverrides };
            
            await updateDoc(gameRef, { [`roundOverrides.${gameData.round}`]: newOverrides });
            
            await calculateScores(true); // Pass true to indicate final calculation
            
            localOverrides = {};
            el.editScoresToggle.checked = false;
            el.scoringModalContent.classList.remove('edit-mode');
            el.applyOverridesBtn.classList.add('hidden');
            el.applyOverridesBtn.disabled = false;
            el.applyOverridesBtn.textContent = 'Apply & Recalculate';
        }
        
        // --- Gameplay Functions ---
        async function handleSubmitWord() {
            const word = currentWord.map(w => w.letter).join('').toUpperCase();
            if (word.length < gameData.minWordLength) { 
                alert(`Word must be at least ${gameData.minWordLength} letters long.`); 
                return; 
            }
            const myCurrentWords = playerWords[userId]?.[gameData.round] || [];
            if (myCurrentWords.includes(word)) { 
                alert("You have already submitted this word."); 
                clearCurrentWord(); 
                return; 
            }
            try { 
                const wordsRef = doc(db, `artifacts/${appId}/public/data/games/${gameId}/playerWords`, userId); 
                await setDoc(wordsRef, { [gameData.round]: [...myCurrentWords, word] }, { merge: true }); 
                clearCurrentWord(); 
            } catch(error) { 
                console.error("Error submitting word:", error); 
            }
        }
        
        function handleDieClick(dieEl, letter, row, col) { 
            if (!dieEl || currentWord.some(d => d.row === row && d.col === col)) return; 
            currentWord.push({ letter, row, col }); 
            dieEl.classList.add('selected'); 
            renderCurrentWord(); 
        }
        
        async function validateWord(word, filters) {
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (!response.ok) return { isValid: false }; 
                const data = await response.json();
                const entry = data[0];
                if (!entry) return { isValid: false };
                let passesFilters = true;
                if (filters.includes('no-plurals')) {
                     if (word.toLowerCase().endsWith('s') && entry.word.toLowerCase() !== word.toLowerCase()) {
                        const singularForm = word.slice(0, -1);
                        if (entry.word.toLowerCase() === singularForm.toLowerCase()) { passesFilters = false; }
                     }
                }
                const partsOfSpeech = new Set(entry.meanings.map(m => m.partOfSpeech));
                const posFilters = filters.filter(f => f !== 'no-plurals');
                if (posFilters.length > 0 && !posFilters.some(f => partsOfSpeech.has(f))) { passesFilters = false; }
                return { isValid: passesFilters };
            } catch (error) { return { isValid: false }; }
        }
        
        async function calculateScores(isFinal = false) {
            if (userId !== gameData.hostId) return null;

            const allWordsDocs = await getDocs(collection(db, `artifacts/${appId}/public/data/games/${gameId}/playerWords`));
            const allPlayerWords = {};
            allWordsDocs.forEach(doc => { allPlayerWords[doc.id] = doc.data() || {}; });
            
            const currentRoundWordsByPlayer = {};
            Object.keys(allPlayerWords).forEach(pid => { currentRoundWordsByPlayer[pid] = allPlayerWords[pid][gameData.round] || []; });
            
            const allWordsInRound = [...new Set(Object.values(currentRoundWordsByPlayer).flat())]; 
            const validationPromises = allWordsInRound.map(word => validateWord(word, gameData.wordFilters || []));
            const validationResults = await Promise.all(validationPromises);
            
            const initialValidWords = allWordsInRound.filter((_, index) => validationResults[index].isValid);
            const overrides = gameData.roundOverrides?.[gameData.round] || {};
            
            let finalValidWords = new Set(initialValidWords);
            for(const word in overrides) {
                if (overrides[word]) finalValidWords.add(word);
                else finalValidWords.delete(word);
            }
            const validWordsList = [...finalValidWords];
            
            const wordCounts = Object.values(currentRoundWordsByPlayer).flat().reduce((acc, word) => { acc[word] = (acc[word] || 0) + 1; return acc; }, {});
            
            const updatedPlayers = { ...gameData.players };
            Object.keys(currentRoundWordsByPlayer).forEach(pid => {
                let roundScore = 0;
                const isSinglePlayer = Object.keys(gameData.players).length === 1;
                currentRoundWordsByPlayer[pid].forEach(word => {
                    const isUnique = wordCounts[word] === 1;
                    if (validWordsList.includes(word) && (isSinglePlayer || isUnique)) {
                        roundScore += word.length;
                    }
                });

                if (updatedPlayers[pid]) {
                    let totalScore = 0;
                    for (const round in updatedPlayers[pid].history) {
                        if (parseInt(round) !== gameData.round) {
                            totalScore += updatedPlayers[pid].history[round];
                        }
                    }
                    totalScore += roundScore;
                    
                    updatedPlayers[pid].score = totalScore;
                    updatedPlayers[pid].roundScore = roundScore; 
                    updatedPlayers[pid].history[gameData.round] = roundScore; 
                }
            });

            const updatePayload = { players: updatedPlayers };
            if (isFinal) {
                updatePayload[`validWordsByRound.${gameData.round}`] = validWordsList;
            }

            await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), updatePayload);
        }
        
        // --- Rendering Functions ---
        function renderGame() { 
            renderLayout(); 
            renderLeaderboard(); 
            renderGameInfoControls(); 
            renderTimerAndStatus(); 
            renderGrid(); 
            renderButtons(); 
        }

        function renderLayout() { 
            const isPlaying = gameData?.status === 'playing' || gameData?.status === 'paused';
            el.leftPanel.classList.toggle('panel-hidden', isPlaying && !el.leftPanel.classList.contains('force-show')); 
            el.rightPanel.classList.toggle('panel-hidden', false);
            el.showPanelsBtn.classList.toggle('hidden', !isPlaying);
            if (!isPlaying) el.leftPanel.classList.remove('force-show');
        }

        function togglePanels() { 
            el.leftPanel.classList.toggle('force-show'); 
            renderLayout(); 
        }

        function renderLeaderboard() { 
            if (!gameData || !gameData.players) { 
                el.leaderboard.innerHTML = '<p>No players yet.</p>'; 
                return; 
            } 
            const playersArray = Object.entries(gameData.players).map(([id, data]) => ({ id, ...data, isHost: id === gameData.hostId })); 
            playersArray.sort((a, b) => b.score - a.score); 
            el.leaderboard.innerHTML = `<table class="w-full text-left"><thead><tr class="border-b-2"><th class="py-2 font-semibold">Player</th><th class="py-2 text-center">Round</th><th class="py-2 text-center">Total</th></tr></thead><tbody>${playersArray.map(p => `<tr class="border-b"><td class="py-2">${p.name} ${p.id === userId ? '(You)' : ''} ${p.isHost ? 'ðŸ‘‘' : ''}</td><td class="py-2 text-center">${p.roundScore}</td><td class="py-2 text-center font-bold">${p.score}</td></tr>`).join('')}</tbody></table>`; 
        }

        function renderGameInfoControls() { 
            if (!gameData) return; 
            const isHost = userId === gameData.hostId; 
            el.gameInfoControls.innerHTML = `<h2 class="text-2xl font-bold text-gray-700 mb-4">Game Info</h2><div><label class="font-semibold">Game ID:</label><div class="flex items-center gap-2 mt-1"><input id="game-id-display-ingame" type="text" readonly class="w-full bg-gray-100 px-3 py-2 border rounded-lg" value="${gameId}"><button id="copy-game-id-btn-ingame" class="bg-gray-200 p-2 rounded-lg"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z"></path><path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z"></path></svg></button></div></div>${isHost ? `<div id="host-controls" class="mt-4 space-y-2"><button id="start-next-round-btn-ingame" class="w-full bg-green-500 text-white font-bold py-2 px-4 rounded-lg"></button><button id="pause-resume-btn-ingame" class="w-full bg-orange-500 text-white font-bold py-2 px-4 rounded-lg"></button><button id="restart-game-btn-ingame" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg">End & Restart Game</button></div>` : ''}`; 
            if (isHost) { 
                document.getElementById('start-next-round-btn-ingame')?.addEventListener('click', handleStartGame); 
                document.getElementById('pause-resume-btn-ingame')?.addEventListener('click', handlePauseResumeGame); 
                document.getElementById('restart-game-btn-ingame')?.addEventListener('click', handleRestartGame); 
            } 
            document.getElementById('copy-game-id-btn-ingame')?.addEventListener('click', () => handleCopyGameId(gameId));
        }
        
        function renderTimerAndStatus() {
            if (!gameData) return;
            const { status, timer, round } = gameData;
            clearInterval(timerInterval);

            if (status === 'playing' && userId === gameData.hostId) {
                timerInterval = setInterval(async () => {
                    const currentTimeLeft = gameData.timer;
                    if (currentTimeLeft > 0) {
                        await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), { timer: currentTimeLeft - 1 });
                    } else {
                        clearInterval(timerInterval);
                        await calculateScores(true);
                        await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), { status: 'scoring' });
                    }
                }, 1000);
            }

            el.timerDisplay.textContent = formatTime(timer || 0);
            if (status === 'playing') {
                el.gameStatusDisplay.textContent = `Round ${round}`;
            } else if (status === 'paused') {
                el.gameStatusDisplay.textContent = `Game Paused`;
            } else if (status === 'scoring') {
                el.gameStatusDisplay.textContent = `Round ${round} Over! Reviewing scores...`;
            } else if (status === 'waiting') {
                el.timerDisplay.textContent = formatTime(gameData.timerDuration || 120);
                el.gameStatusDisplay.textContent = "Waiting for host...";
            }
        }
        
        function renderGrid() {
            const { status, gridSize } = gameData; 
            let grid;
            try { grid = typeof gameData.grid === 'string' ? JSON.parse(gameData.grid) : []; } catch (e) { grid = []; }
            el.gameGrid.innerHTML = ''; 
            const size = gridSize || 4;
            el.gameGrid.style.gridTemplateColumns = `repeat(${size}, minmax(0, 1fr))`;
            if (status === 'waiting' || !grid || grid.length === 0) { 
                el.gameGrid.innerHTML = Array.from({length: size * size}).map(() => `<div class="aspect-square bg-gray-200 rounded-lg animate-pulse"></div>`).join(''); 
                return; 
            }
            grid.forEach((row, r) => { row.forEach((letter, c) => { 
                const dieEl = document.createElement('button'); 
                dieEl.className = 'die flex items-center justify-center text-2xl md:text-3xl font-bold uppercase bg-white rounded-lg cursor-pointer hover:bg-indigo-100'; 
                dieEl.textContent = letter; dieEl.dataset.row = r; dieEl.dataset.col = c; 
                if (status === 'playing') dieEl.onclick = () => handleDieClick(dieEl, letter, r, c); 
                else { dieEl.disabled = true; dieEl.classList.add('cursor-not-allowed', 'opacity-70'); } 
                el.gameGrid.appendChild(dieEl); }); });
        }
        
        function renderButtons() {
            if (!gameData || !gameData.players) return;
            const { status, hostId, round } = gameData;
            const isHost = userId === hostId;
            if (isHost && document.getElementById('host-controls')) {
                const startNextBtn = document.getElementById('start-next-round-btn-ingame');
                const pauseResumeBtn = document.getElementById('pause-resume-btn-ingame');
                const restartBtn = document.getElementById('restart-game-btn-ingame');
                if (startNextBtn) { startNextBtn.classList.toggle('hidden', status === 'playing' || status === 'paused'); startNextBtn.textContent = (round || 0) === 0 ? 'Start Game' : 'Start Next Round';}
                if(pauseResumeBtn) { const isPausable = (status === 'playing' || status === 'paused'); pauseResumeBtn.classList.toggle('hidden', !isPausable); if(isPausable) pauseResumeBtn.textContent = status === 'playing' ? 'Pause' : 'Resume'; }
                if(restartBtn) restartBtn.classList.toggle('hidden', status === 'playing' || status === 'paused');
            }
            const isPlaying = status === 'playing'; el.submitWordBtn.disabled = !isPlaying; el.clearWordBtn.disabled = !isPlaying;
        }

        function renderCurrentWord() { el.currentWordDisplay.textContent = currentWord.map(w => w.letter).join(''); }
        function renderMyWords() { const myWords = playerWords[userId]?.[gameData.round] || []; el.myWordsList.innerHTML = myWords.map(word => `<li class="p-2 bg-white rounded shadow-sm mb-2">${word}</li>`).join(''); el.myWordsList.scrollTop = el.myWordsList.scrollHeight; }
        
        async function showDefinition(word) {
            el.dictionaryWord.textContent = 'Loading...'; 
            el.dictionaryDefinition.innerHTML = '';
            bringToFront(el.dictionaryModal);
            el.dictionaryModal.classList.remove('hidden');
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                el.dictionaryWord.textContent = word;
                if (!response.ok) { 
                    el.dictionaryDefinition.textContent = "No definition found."; 
                    return; 
                }
                const data = await response.json();
                el.dictionaryDefinition.innerHTML = ''; // Clear loading
                data[0].meanings.forEach(meaning => {
                    const partOfSpeech = document.createElement('strong'); 
                    partOfSpeech.className = "block mt-2 capitalize font-bold"; 
                    partOfSpeech.textContent = meaning.partOfSpeech;
                    el.dictionaryDefinition.appendChild(partOfSpeech);
                    const definitionsList = document.createElement('ul'); 
                    definitionsList.className = 'list-disc list-inside space-y-1';
                    meaning.definitions.forEach(def => { 
                        const li = document.createElement('li'); 
                        li.textContent = def.definition; 
                        definitionsList.appendChild(li); 
                    });
                    el.dictionaryDefinition.appendChild(definitionsList);
                });
            } catch (error) { 
                el.dictionaryWord.textContent = word; 
                el.dictionaryDefinition.textContent = "Error fetching definition."; 
            }
        }
        
        function hideDefinition() { el.dictionaryModal.classList.add('hidden'); }

        async function showScoringModal() {
            localOverrides = {}; 
            el.scoringHostControls.classList.toggle('hidden', userId !== gameData.hostId);
            el.editScoresToggle.checked = false;
            el.scoringModalContent.classList.remove('edit-mode');
            el.applyOverridesBtn.classList.add('hidden');
            el.revealTopWordsBtn.disabled = false;
            
            const validWordsForRound = gameData.validWordsByRound?.[gameData.round] || [];
            
            el.scoringModalContent.innerHTML = '<div class="col-span-full text-center">Loading scores...</div>';

            const allWordsDocs = await getDocs(collection(db, `artifacts/${appId}/public/data/games/${gameId}/playerWords`));
            const allWords = {};
            allWordsDocs.forEach(doc => { allWords[doc.id] = doc.data() || {}; });
            
            el.scoringModalContent.innerHTML = '';
            const sortedPlayers = Object.entries(gameData.players).sort(([,a], [,b]) => b.roundScore - a.roundScore);

            for (const [pid, player] of sortedPlayers) {
                const words = allWords[pid]?.[gameData.round] || [];
                const playerCard = document.createElement('div');
                playerCard.className = 'border rounded-lg p-4 bg-gray-50 flex flex-col';
                playerCard.innerHTML = `<h3 class="player-score-header font-bold text-xl mb-3">${player.name} - ${player.roundScore} pts</h3><ul class="space-y-1 h-48 overflow-y-auto pr-2 flex-grow"></ul>`;
                const wordListEl = playerCard.querySelector('ul');

                if (words.length === 0) { 
                    wordListEl.innerHTML = '<li class="text-gray-400">No words submitted.</li>'; 
                } else {
                    const wordCounts = Object.values(allWords).flatMap(pWords => pWords[gameData.round] || []).reduce((acc, word) => { acc[word] = (acc[word] || 0) + 1; return acc; }, {});
                    
                    words.sort().forEach(word => {
                        const isUnique = wordCounts[word] === 1;
                        const isWordValid = validWordsForRound.includes(word);
                        const points = isWordValid && (isUnique || Object.keys(gameData.players).length === 1) ? word.length : 0;
                        
                        const li = document.createElement('li');
                        li.className = `flex justify-between items-center p-1 rounded word-list-item`;
                        li.dataset.word = word;
                        
                        let validityClass = 'text-gray-500 line-through'; let pointText = '0';
                        if (points > 0) { validityClass = 'font-semibold text-green-600'; pointText = `+${points}`; } 
                        else if (isWordValid && !isUnique) { validityClass = 'text-yellow-600'; pointText = '0'; }
                        
                        li.innerHTML = `
                            <span class="word-text cursor-pointer hover:underline">${word}</span>
                            <div class="flex items-center gap-2">
                                <span class="word-points ${validityClass}">${pointText}</span>
                                <button class="host-override-btn text-lg text-green-500 hover:text-green-700" data-action="approve">ðŸ‘</button>
                                <button class="host-override-btn text-lg text-red-500 hover:text-red-700" data-action="reject">ðŸ‘Ž</button>
                            </div>
                        `;
                        
                        li.querySelector('.word-text').addEventListener('click', () => showDefinition(word));
                        li.querySelectorAll('.host-override-btn').forEach(btn => btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const action = e.target.dataset.action;
                            localOverrides[word] = (action === 'approve');
                            
                            li.classList.remove('word-overridden-approve', 'word-overridden-reject');
                            const pointSpan = li.querySelector('.word-points');
                            if (action === 'approve') {
                                li.classList.add('word-overridden-approve');
                                pointSpan.className = 'word-points font-semibold text-green-600';
                                pointSpan.textContent = `+${word.length}`;
                            } else {
                                li.classList.add('word-overridden-reject');
                                pointSpan.className = 'word-points text-gray-500 line-through';
                                pointSpan.textContent = '0';
                            }
                        }));
                        wordListEl.appendChild(li);
                    });
                }
                el.scoringModalContent.appendChild(playerCard);
            }
            bringToFront(el.scoringModal);
            el.scoringModal.classList.remove('hidden');
        }

        async function showStandingsModal() {
            const content = el.standingsModalContent; content.innerHTML = '<div class="text-center">Loading...</div>';
            let table = `<table class="w-full text-left table-fixed"><thead class="bg-gray-100"><tr><th class="p-2 w-1/3">Player</th>`;
            const rounds = Array.from({length: gameData.round || 0}, (_, i) => i + 1);
            rounds.forEach(r => { table += `<th class="p-2 text-center cursor-pointer hover:bg-gray-200 round-history-btn" data-round="${r}">R${r}</th>`});
            table += `<th class="p-2 text-center font-bold">Total</th></tr></thead><tbody>`;
            const players = Object.values(gameData.players).sort((a, b) => b.score - a.score);
            players.forEach(p => {
                table += `<tr class="border-b"><td class="p-2 font-semibold">${p.name}</td>`;
                rounds.forEach(r => { table += `<td class="p-2 text-center">${p.history[r] || 0}</td>` });
                table += `<td class="p-2 text-center font-bold">${p.score}</td></tr>`;
            });
            table += `</tbody></table><div id="round-words-view" class="mt-4 p-4 bg-gray-50 rounded hidden"></div>`;
            content.innerHTML = table;
            content.querySelectorAll('.round-history-btn').forEach(btn => btn.addEventListener('click', async (e) => {
                const roundNum = e.target.dataset.round;
                const wordView = document.getElementById('round-words-view');
                wordView.classList.remove('hidden');
                wordView.innerHTML = `<h3 class="text-xl font-bold mb-2">Words from Round ${roundNum}</h3><div class="text-center">Loading words...</div>`;
                const allWordsDocs = await getDocs(collection(db, `artifacts/${appId}/public/data/games/${gameId}/playerWords`));
                const allWordsData = {};
                allWordsDocs.forEach(doc => { allWordsData[doc.id] = doc.data() || {}; });
                wordView.innerHTML = `<h3 class="text-xl font-bold mb-2">Words from Round ${roundNum}</h3>`;
                for(const pid in gameData.players) {
                    const pName = gameData.players[pid].name; const words = allWordsData[pid]?.[roundNum] || [];
                    const playerWordsDiv = document.createElement('div'); playerWordsDiv.className = 'mb-2';
                    playerWordsDiv.innerHTML = `<strong class="font-semibold">${pName}:</strong> `;
                    if (words.length > 0) { words.forEach((word, index) => { const wordSpan = document.createElement('span'); wordSpan.className = 'cursor-pointer text-blue-600 hover:underline'; wordSpan.textContent = word; wordSpan.onclick = () => showDefinition(word); playerWordsDiv.appendChild(wordSpan); if (index < words.length - 1) playerWordsDiv.append(', '); });
                    } else { playerWordsDiv.append('None'); }
                    wordView.appendChild(playerWordsDiv);
                }
            }));
            bringToFront(el.standingsModal);
            el.standingsModal.classList.remove('hidden');
        }

        async function getTopWordsFromGemini(gridLetters, filters, round) {
            const systemPrompt = `You are an expert lexicographer for a word game. Your task is to identify the highest-scoring valid English words that can be constructed from a given set of letters.
Constraints:
1. You will be given an array of single-character strings (the 'grid letters').
2. You can only use each letter from the input array once per word.
3. All generated words must be valid English dictionary words.
4. The generated words must match one of the provided part-of-speech filters, if any are provided. A special filter "no-plurals" means you should avoid plural nouns.
5. Prioritize longer words as they score more points.
Output Format:
Your response must be a single, valid JSON object. The object should contain a single key, "topWords", which is an array of objects. Each object in the array should have two keys: "word" (the generated word as a string) and "score" (the word's length as an integer). Provide up to 10 of the highest-scoring words. If fewer than 10 words can be formed, return as many as you can find. If no valid words can be formed, return an empty array.`;

            const userPrompt = JSON.stringify({ letters: gridLetters, minLength: gameData.minWordLength, filters: filters });

            const payload = {
                contents: [{ role: "user", parts: [{ text: `${systemPrompt}\n\nHere is the request:\n${userPrompt}` }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            topWords: {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        word: { type: "STRING" },
                                        score: { type: "NUMBER" },
                                    },
                                    required: ["word", "score"],
                                },
                            },
                        },
                        required: ["topWords"],
                    },
                },
            };

            const apiKey = "AIzaSyB3ngRcUo2C2Y1Us6lmQWKiGrGRodXI6-Q"; // API Key is handled by the environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();

                if (result.candidates && result.candidates[0]?.content?.parts[0]?.text) {
                    try {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        const data = JSON.parse(jsonText);
                        
                        if (data.topWords) {
                             await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), {
                                [`topWordsByRound.${round}`]: data.topWords
                             });
                        }
                    } catch (e) {
                         console.error("Error parsing JSON response from Gemini:", e);
                         console.error("Received text that failed to parse:", result.candidates[0].content.parts[0].text);
                    }
                } else {
                    console.error("No valid candidate text returned from Gemini API.", result);
                }
            } catch (error) {
                console.error("Error during Gemini API fetch:", error);
            }
        }

        function handleRevealTopWords() {
            el.topWordsContent.innerHTML = '';
            const topWords = gameData.topWordsByRound?.[gameData.round];

            if (topWords && topWords.length > 0) {
                 el.topWordsContent.innerHTML = `<ul class="space-y-2">${topWords.map(item => `<li class="flex justify-between items-center p-2 bg-gray-100 rounded"><button data-word="${item.word}" class="font-bold uppercase hover:underline">${item.word}</button><span>${item.score} pts</span></li>`).join('')}</ul>`;
                 el.topWordsContent.querySelectorAll('button[data-word]').forEach(btn => {
                    btn.addEventListener('click', () => showDefinition(btn.dataset.word));
                });
            } else {
                el.topWordsContent.innerHTML = '<p class="text-center">Top words are being generated. Please try again in a moment.</p>';
            }
            el.topWordsModal.classList.remove('hidden');
            bringToFront(el.topWordsModal);
        }
        
        // --- Keyboard Handling ---
        function handleKeyDown(event) {
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
            if (gameData?.status !== 'playing') return;
            if (event.key === 'Enter') { event.preventDefault(); el.submitWordBtn.click(); } 
            else if (event.key === 'Backspace') { 
                event.preventDefault();
                if(currentWord.length > 0){
                    const lastDie = currentWord.pop();
                    const dieEl = document.querySelector(`.die[data-row='${lastDie.row}'][data-col='${lastDie.col}']`);
                    if(dieEl) dieEl.classList.remove('selected');
                    renderCurrentWord();
                }
            } else if (/^[a-zA-Z]$/.test(event.key)) {
                event.preventDefault(); const letter = event.key.toUpperCase(); const grid = JSON.parse(gameData.grid); const size = gameData.gridSize;
                const isSelected = (r, c) => currentWord.some(d => d.row === r && d.col === c);
                for (let r = 0; r < size; r++) { let foundDie = false; for (let c = 0; c < size; c++) { if (grid[r][c] === letter && !isSelected(r,c)) { const dieEl = document.querySelector(`.die[data-row='${r}'][data-col='${c}']`); handleDieClick(dieEl, grid[r][c], r, c); foundDie = true; break; }} if (foundDie) break;}
            }
        }
        
        // --- Modal Drag/Resize Utilities ---
        function bringToFront(modal) { highestZ++; modal.style.zIndex = highestZ; }
        function setupModal(modal) {
            const header = modal.querySelector('.modal-header'); const resizeHandle = modal.querySelector('.resize-handle');
            modal.addEventListener('mousedown', () => bringToFront(modal));
            if (header) makeDraggable(modal, header); if (resizeHandle) makeResizable(modal, resizeHandle);
        }
        function makeDraggable(element, header) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; header.onmousedown = dragMouseDown;
            function dragMouseDown(e) { e = e || window.event; e.preventDefault(); pos3 = e.clientX; pos4 = e.clientY; document.onmouseup = closeDragElement; document.onmousemove = elementDrag; }
            function elementDrag(e) { e = e || window.event; e.preventDefault(); pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; element.style.top = (element.offsetTop - pos2) + "px"; element.style.left = (element.offsetLeft - pos1) + "px"; }
            function closeDragElement() { document.onmouseup = null; document.onmousemove = null; }
        }
        function makeResizable(element, handle) {
            let initialWidth, initialHeight, initialX, initialY; handle.onmousedown = startResize;
            function startResize(e) { e.preventDefault(); initialWidth = element.offsetWidth; initialHeight = element.offsetHeight; initialX = e.clientX; initialY = e.clientY; document.onmousemove = resizeElement; document.onmouseup = stopResize; }
            function resizeElement(e) { const newWidth = initialWidth + (e.clientX - initialX); const newHeight = initialHeight + (e.clientY - initialY); if (newWidth > 300) element.style.width = newWidth + 'px'; if (newHeight > 200) element.style.height = newHeight + 'px'; }
            function stopResize() { document.onmousemove = null; document.onmouseup = null; }
        }
        
        // --- General Utilities ---
        function clearCurrentWord() { currentWord = []; renderCurrentWord(); document.querySelectorAll('.die.selected').forEach(el => el.classList.remove('selected')); }
        function formatTime(seconds) { const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
        function handleCopyGameId(id) { 
            if (navigator.clipboard) { navigator.clipboard.writeText(id).then(() => { alert('Game ID copied!'); }, () => { alert('Failed to copy.'); });
            } else { const input = document.createElement('textarea'); input.value = id; document.body.appendChild(input); input.select(); try { document.execCommand('copy'); alert('Game ID copied!'); } catch (err) { alert('Failed to copy.'); } document.body.removeChild(input); }
        }
        function listenForPlayerWords() {
            if (!gameData || !gameData.players) return; const playerIds = Object.keys(gameData.players);
            Object.keys(wordsUnsubscribe).forEach(pid => { if (!playerIds.includes(pid)) { wordsUnsubscribe[pid](); delete wordsUnsubscribe[pid]; }});
            playerIds.forEach(pid => { if (!wordsUnsubscribe[pid]) { const wordsRef = doc(db, `artifacts/${appId}/public/data/games/${gameId}/playerWords`, pid); wordsUnsubscribe[pid] = onSnapshot(wordsRef, (doc) => { playerWords[pid] = doc.data() || {}; if (pid === userId) renderMyWords(); });}});
        }

        // Close modal on outside click
        window.addEventListener('click', (e) => {
            if (!el.dictionaryModal.classList.contains('hidden') && !el.dictionaryModal.contains(e.target) && !e.target.closest('.word-text') && !e.target.closest('button[data-word]')) {
                hideDefinition();
            }
        });

    </script>
</body>
</html>
